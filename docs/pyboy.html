<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>pyboy.pyboy API documentation</title>
<meta name="description" content="The core module of the emulator" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyboy.pyboy</code></h1>
</header>
<section id="section-intro">
<p>The core module of the emulator</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#
# License: See LICENSE file
# GitHub: https://github.com/Baekalfen/PyBoy
#

&#34;&#34;&#34;
The core module of the emulator
&#34;&#34;&#34;

import logging
import os
import time

from pyboy.plugins.manager import PluginManager
from pyboy.utils import IntIOWrapper, WindowEvent

from . import botsupport
from .core.mb import Motherboard

logger = logging.getLogger(__name__)

SPF = 1/60. # inverse FPS (frame-per-second)

defaults = {
    &#34;color_palette&#34;: (0xFFFFFF, 0x999999, 0x555555, 0x000000),
    &#34;scale&#34;: 3,
    &#34;window_type&#34;: &#34;SDL2&#34;,
}


class PyBoy:
    def __init__(
                self,
                gamerom_file, *,
                bootrom_file=None,
                profiling=False,
                disable_renderer=False,
                **kwargs
            ):
        &#34;&#34;&#34;
        PyBoy is loadable as an object in Python. This means, it can be initialized from another script, and be
        controlled and probed by the script. It is supported to spawn multiple emulators, just instantiate the class
        multiple times.

        This object, `pyboy.WindowEvent`, and the `pyboy.botsupport` module, are the only official user-facing
        interfaces. All other parts of the emulator, are subject to change.

        A range of methods are exposed, which should allow for complete control of the emulator. Please open an issue on
        GitHub, if other methods are needed for your projects. Take a look at `interface_example.py` or `tetris_bot.py`
        for a crude &#34;bot&#34;, which interacts with the game.

        Only the `gamerom_file` argument is required.

        Args:
            gamerom_file (str): Filepath to a game-ROM for the original Game Boy.

        Kwargs:
            bootrom_file (str): Filepath to a boot-ROM to use. If unsure, specify `None`.
            profiling (bool): Profile the emulator and report opcode usage (internal use).
            disable_renderer (bool): Can be used to optimize performance, by internally disable rendering of the screen.
            color_palette (tuple): Specify the color palette to use for rendering.
        &#34;&#34;&#34;

        for k, v in defaults.items():
            if k not in kwargs:
                kwargs[k] = kwargs.get(k, defaults[k])

        if not os.path.isfile(gamerom_file):
            raise FileNotFoundError(f&#34;ROM file {gamerom_file} was not found!&#34;)
        self.gamerom_file = gamerom_file

        self.mb = Motherboard(
            gamerom_file,
            bootrom_file,
            kwargs[&#34;color_palette&#34;],
            disable_renderer,
            profiling=profiling
        )

        # Performance measures
        self.avg_pre = 0
        self.avg_tick = 0
        self.avg_post = 0

        # Absolute frame count of the emulation
        self.frame_count = 0

        self.set_emulation_speed(1)
        self.paused = False
        self.events = []
        self.done = False
        self.window_title = &#34;PyBoy&#34;

        ###################
        # Plugins

        self.plugin_manager = PluginManager(self, self.mb, kwargs)

    def tick(self):
        &#34;&#34;&#34;
        Progresses the emulator ahead by one frame.

        To run the emulator in real-time, this will need to be called 60 times a second (for example in a while-loop).
        This function will block for roughly 16,67ms at a time, to not run faster than real-time, unless you specify
        otherwise with the `PyBoy.set_emulation_speed` method.

        _Open an issue on GitHub if you need finer control, and we will take a look at it._
        &#34;&#34;&#34;

        t_start = time.perf_counter() # Change to _ns when PyPy supports it
        self._handle_events(self.events)
        t_pre = time.perf_counter()
        self.frame_count += 1
        if not self.paused:
            self.mb.tickframe()
        t_tick = time.perf_counter()
        self._post_tick()
        t_post = time.perf_counter()

        secs = t_pre-t_start
        self.avg_pre = 0.9 * self.avg_pre + 0.1 * secs

        secs = t_tick-t_pre
        self.avg_tick = 0.9 * self.avg_tick + 0.1 * secs

        secs = t_post-t_tick
        self.avg_post = 0.9 * self.avg_post + 0.1 * secs

        return self.done

    def _handle_events(self, events):
        # This feeds events into the tick-loop from the window. There might already be events in the list from the API.
        events = self.plugin_manager.handle_events(events)

        for event in events:
            if event == WindowEvent.QUIT:
                self.done = True
            elif event == WindowEvent.RELEASE_SPEED_UP:
                # Switch between unlimited and 1x real-time emulation speed
                self.target_emulationspeed = int(bool(self.target_emulationspeed) ^ True)
                logger.info(&#34;Speed limit: %s&#34; % self.target_emulationspeed)
            elif event == WindowEvent.STATE_SAVE:
                with open(self.gamerom_file + &#34;.state&#34;, &#34;wb&#34;) as f:
                    self.mb.save_state(IntIOWrapper(f))
            elif event == WindowEvent.STATE_LOAD:
                with open(self.gamerom_file + &#34;.state&#34;, &#34;rb&#34;) as f:
                    self.mb.load_state(IntIOWrapper(f))
            elif event == WindowEvent.PASS:
                pass # Used in place of None in Cython, when key isn&#39;t mapped to anything
            elif event == WindowEvent.PAUSE_TOGGLE:
                if self.paused:
                    self._unpause()
                else:
                    self._pause()
            elif event == WindowEvent.PAUSE:
                self._pause()
            elif event == WindowEvent.UNPAUSE:
                self._unpause()
            elif event == WindowEvent._INTERNAL_RENDERER_FLUSH:
                self.plugin_manager._post_tick_windows()
            else:
                self.mb.buttonevent(event)

    def _pause(self):
        if self.paused:
            return
        self.paused = True
        self.save_target_emulationspeed = self.target_emulationspeed
        self.target_emulationspeed = 1
        logger.info(&#34;Emulation paused!&#34;)
        self._update_window_title()

    def _unpause(self):
        if not self.paused:
            return
        self.paused = False
        self.target_emulationspeed = self.save_target_emulationspeed
        logger.info(&#34;Emulation unpaused!&#34;)
        self._update_window_title()

    def _post_tick(self):
        if self.frame_count % 60 == 0:
            self._update_window_title()
        self.plugin_manager.post_tick()
        self.plugin_manager.frame_limiter(self.target_emulationspeed)

        # Prepare an empty list, as the API might be used to send in events between ticks
        self.events = []

    def _update_window_title(self):
        avg_emu = self.avg_pre + self.avg_tick + self.avg_post
        self.window_title = &#34;CPU/frame: %0.2f%%&#34; % ((self.avg_pre + self.avg_tick)/SPF*100)
        self.window_title += &#34; Emulation: x%d&#34; % (round(SPF/avg_emu) if avg_emu != 0 else 0)
        if self.paused:
            self.window_title += &#34;[PAUSED]&#34;
        self.window_title += self.plugin_manager.window_title()
        self.plugin_manager._set_title()

    def __del__(self):
        self.stop(save=False)

    def stop(self, save=True):
        &#34;&#34;&#34;
        Gently stops the emulator and all sub-modules.

        Args:
            save (bool): Specify whether to save the game upon stopping. It will always be saved in a file next to the
                provided game-ROM.
        &#34;&#34;&#34;
        logger.info(&#34;###########################&#34;)
        logger.info(&#34;# Emulator is turning off #&#34;)
        logger.info(&#34;###########################&#34;)
        self.plugin_manager.stop()
        self.mb.stop(save)

    def _cpu_hitrate(self):
        logger.warning(&#34;You are calling an internal function. The output and the function is subject to change.&#34;)
        return self.mb.cpu.hitrate

    ###################################################################
    # Scripts and bot methods
    #

    def screen(self):
        &#34;&#34;&#34;
        Use this method to get a `pyboy.botsupport.screen.Screen` object. This can be used to get the screen buffer in
        a variety of formats.

        It&#39;s also here you can find the screen position (SCX, SCY, WX, WY) for each scan line in the screen buffer. See
        `pyboy.botsupport.screen.Screen.tilemap_position` for more information.

        Returns
        -------
        `pyboy.botsupport.screen.Screen`:
            A Screen object with helper functions for reading the screen buffer.
        &#34;&#34;&#34;
        return botsupport.screen.Screen(self.mb)

    def memory_value(self, addr):
        &#34;&#34;&#34;
        Reads a given memory address of the Game Boy&#39;s current memory state. This will not directly give you access to
        all switchable memory banks. Open an issue on GitHub if that is needed, or use `PyBoy.set_memory_value` to send
        MBC commands to the virtual cartridge.

        Returns
        -------
        int:
            An integer with the value of the memory address
        &#34;&#34;&#34;
        return self.mb.getitem(addr)

    def set_memory_value(self, addr, value):
        &#34;&#34;&#34;
        Write one byte to a given memory address of the Game Boy&#39;s current memory state.

        This will not directly give you access to all switchable memory banks. Open an issue on GitHub if that is
        needed, or use this function to send &#34;Memory Bank Controller&#34; (MBC) commands to the virtual cartridge. You can
        read about the MBC at [Pan Docs](http://bgb.bircd.org/pandocs.htm).

        Args:
            addr (int): Address to write the byte
            value (int): A byte of data
        &#34;&#34;&#34;
        self.mb.setitem(addr, value)

    def send_input(self, event):
        &#34;&#34;&#34;
        Send a single input to control the emulator. This is both Game Boy buttons and emulator controls.

        See `pyboy.WindowEvent` for which events to send.

        Args:
            event (pyboy.WindowEvent): The event to send
        &#34;&#34;&#34;
        self.events.append(WindowEvent(event))

    def sprite(self, sprite_index):
        &#34;&#34;&#34;
        Provides a `pyboy.botsupport.sprite.Sprite` object, which makes the OAM data more presentable. The given index
        corresponds to index of the sprite in the &#34;Object Attribute Memory&#34; (OAM).

        The Game Boy supports 40 sprites in total. Read more details about it, in the [Pan
        Docs](http://bgb.bircd.org/pandocs.htm).

        Args:
            index (int): Sprite index from 0 to 39.
        Returns
        -------
        `pyboy.botsupport.sprite.Sprite`:
            Sprite corresponding to the given index.
        &#34;&#34;&#34;
        return botsupport.Sprite(self.mb, sprite_index)

    def sprite_by_tile_identifier(self, tile_identifiers, on_screen=True):
        &#34;&#34;&#34;
        Provided a list of tile identifiers, this function will find all occurrences of sprites using the tile
        identifiers and return the sprite indexes where each identifier is found. Use the sprite indexes in the
        `pyboy.PyBoy.sprite` function to get a `pyboy.botsupport.sprite.Sprite` object.

        Example:
        ```
        &gt;&gt;&gt; print(pyboy.sprite_by_tile_identifier([43, 123]))
        [[0, 2, 4], []]
        ```

        Meaning, that tile identifier `43` is found at the sprite indexes: 0, 2, and 4, while tile identifier
        `123` was not found anywhere.

        Args:
            identifiers (list): List of tile identifiers (int)
            on_screen (bool): Require that the matched sprite is on screen

        Returns
        -------
        list:
            list of sprite matches for every tile identifier in the input
        &#34;&#34;&#34;

        matches = []
        for i in tile_identifiers:
            match = []
            for s in range(botsupport.constants.SPRITES):
                sprite = botsupport.sprite.Sprite(self.mb, s)
                for t in sprite.tiles:
                    if t.tile_identifier == i and sprite.on_screen:
                        match.append(s)
            matches.append(match)
        return matches

    def tile(self, identifier):
        &#34;&#34;&#34;
        The Game Boy can have 384 tiles loaded in memory at once. Use this method to get a
        `pyboy.botsupport.tile.Tile`-object for given identifier.

        The identifier is a PyBoy construct, which unifies two different scopes of indexes in the Game Boy hardware. See
        the `pyboy.botsupport.tile.Tile` object for more information.

        Returns
        -------
        `pyboy.botsupport.tile.Tile`:
            A Tile object for the given identifier.
        &#34;&#34;&#34;
        return botsupport.Tile(self.mb, identifier=identifier)

    def tilemap_background(self):
        &#34;&#34;&#34;
        The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
        for the _background_ tiles. The game chooses whether it wants to use the low or the high tilemap.

        Read more details about it, in the [Pan Docs](http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps).

        Returns
        -------
        `pyboy.botsupport.tilemap.TileMap`:
            A TileMap object for the tile map.
        &#34;&#34;&#34;
        return botsupport.TileMap(self.mb, &#34;BACKGROUND&#34;)

    def tilemap_window(self):
        &#34;&#34;&#34;
        The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
        for the _window_ tiles. The game chooses whether it wants to use the low or the high tilemap.

        Read more details about it, in the [Pan Docs](http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps).

        Returns
        -------
        `pyboy.botsupport.tilemap.TileMap`:
            A TileMap object for the tile map.
        &#34;&#34;&#34;
        return botsupport.TileMap(self.mb, &#34;WINDOW&#34;)

    def save_state(self, file_like_object):
        &#34;&#34;&#34;
        Saves the complete state of the emulator. It can be called at any time, and enable you to revert any progress in
        a game.

        You can either save it to a file, or in-memory. The following two examples will provide the file handle in each
        case. Remember to `seek` the in-memory buffer to the beginning before calling `PyBoy.load_state`:

            # Save to file
            file_like_object = open(&#34;state_file.state&#34;, &#34;wb&#34;)

            # Save to memory
            import io
            file_like_object = io.BytesIO()
            file_like_object.seek(0)

        Args:
            file_like_object (io.BufferedIOBase): A file-like object for which to write the emulator state.
        &#34;&#34;&#34;

        if isinstance(file_like_object, str):
            raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

        self.mb.save_state(IntIOWrapper(file_like_object))

    def load_state(self, file_like_object):
        &#34;&#34;&#34;
        Restores the complete state of the emulator. It can be called at any time, and enable you to revert any progress
        in a game.

        You can either load it from a file, or from memory. See `PyBoy.save_state` for how to save the state, before you
        can load it here.

        To load a file, remember to load it as bytes:

            # Load file
            file_like_object = open(&#34;state_file.state&#34;, &#34;rb&#34;)


        Args:
            file_like_object (io.BufferedIOBase): A file-like object for which to read the emulator state.
        &#34;&#34;&#34;

        if isinstance(file_like_object, str):
            raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

        self.mb.load_state(IntIOWrapper(file_like_object))

    def _serial(self):
        &#34;&#34;&#34;
        Provides all data that has been sent over the serial port since last call to this function.

        Returns
        -------
        str :
            Buffer data
        &#34;&#34;&#34;
        return self.mb.getserial()

    def set_emulation_speed(self, target_speed):
        &#34;&#34;&#34;
        Set the target emulation speed. It might loose accuracy of keeping the exact speed, when using a high
        `target_speed`.

        The speed is defined as a multiple of real-time. I.e `target_speed=2` is double speed.

        A `target_speed` of `0` means unlimited. I.e. fastest possible execution.

        Args:
            target_speed (int): Target emulation speed as multiplier of real-time.
        &#34;&#34;&#34;
        if target_speed &gt; 5:
            logger.warning(&#34;The emulation speed might not be accurate when speed-target is higher than 5&#34;)
        self.target_emulationspeed = target_speed

    def cartridge_title(self):
        &#34;&#34;&#34;
        Get the title stored on the currently loaded cartridge ROM. The title is all upper-case ASCII and may
        have been truncated to 11 characters.

        Returns
        -------
        str :
            Game title
        &#34;&#34;&#34;
        return self.mb.cartridge.gamename</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyboy.pyboy.PyBoy"><code class="flex name class">
<span>class <span class="ident">PyBoy</span></span>
<span>(</span><span>gamerom_file, *, bootrom_file=None, profiling=False, disable_renderer=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>PyBoy is loadable as an object in Python. This means, it can be initialized from another script, and be
controlled and probed by the script. It is supported to spawn multiple emulators, just instantiate the class
multiple times.</p>
<p>This object, <a title="pyboy.WindowEvent" href="index.html#pyboy.WindowEvent"><code>WindowEvent</code></a>, and the <a title="pyboy.botsupport" href="botsupport/index.html"><code>pyboy.botsupport</code></a> module, are the only official user-facing
interfaces. All other parts of the emulator, are subject to change.</p>
<p>A range of methods are exposed, which should allow for complete control of the emulator. Please open an issue on
GitHub, if other methods are needed for your projects. Take a look at <code>interface_example.py</code> or <code>tetris_bot.py</code>
for a crude "bot", which interacts with the game.</p>
<p>Only the <code>gamerom_file</code> argument is required.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gamerom_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Filepath to a game-ROM for the original Game Boy.</dd>
</dl>
<h2 id="kwargs">Kwargs</h2>
<dl>
<dt><strong><code>bootrom_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Filepath to a boot-ROM to use. If unsure, specify <code>None</code>.</dd>
<dt><strong><code>profiling</code></strong> :&ensp;<code>bool</code></dt>
<dd>Profile the emulator and report opcode usage (internal use).</dd>
<dt><strong><code>disable_renderer</code></strong> :&ensp;<code>bool</code></dt>
<dd>Can be used to optimize performance, by internally disable rendering of the screen.</dd>
<dt><strong><code>color_palette</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Specify the color palette to use for rendering.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class PyBoy:
    def __init__(
                self,
                gamerom_file, *,
                bootrom_file=None,
                profiling=False,
                disable_renderer=False,
                **kwargs
            ):
        &#34;&#34;&#34;
        PyBoy is loadable as an object in Python. This means, it can be initialized from another script, and be
        controlled and probed by the script. It is supported to spawn multiple emulators, just instantiate the class
        multiple times.

        This object, `pyboy.WindowEvent`, and the `pyboy.botsupport` module, are the only official user-facing
        interfaces. All other parts of the emulator, are subject to change.

        A range of methods are exposed, which should allow for complete control of the emulator. Please open an issue on
        GitHub, if other methods are needed for your projects. Take a look at `interface_example.py` or `tetris_bot.py`
        for a crude &#34;bot&#34;, which interacts with the game.

        Only the `gamerom_file` argument is required.

        Args:
            gamerom_file (str): Filepath to a game-ROM for the original Game Boy.

        Kwargs:
            bootrom_file (str): Filepath to a boot-ROM to use. If unsure, specify `None`.
            profiling (bool): Profile the emulator and report opcode usage (internal use).
            disable_renderer (bool): Can be used to optimize performance, by internally disable rendering of the screen.
            color_palette (tuple): Specify the color palette to use for rendering.
        &#34;&#34;&#34;

        for k, v in defaults.items():
            if k not in kwargs:
                kwargs[k] = kwargs.get(k, defaults[k])

        if not os.path.isfile(gamerom_file):
            raise FileNotFoundError(f&#34;ROM file {gamerom_file} was not found!&#34;)
        self.gamerom_file = gamerom_file

        self.mb = Motherboard(
            gamerom_file,
            bootrom_file,
            kwargs[&#34;color_palette&#34;],
            disable_renderer,
            profiling=profiling
        )

        # Performance measures
        self.avg_pre = 0
        self.avg_tick = 0
        self.avg_post = 0

        # Absolute frame count of the emulation
        self.frame_count = 0

        self.set_emulation_speed(1)
        self.paused = False
        self.events = []
        self.done = False
        self.window_title = &#34;PyBoy&#34;

        ###################
        # Plugins

        self.plugin_manager = PluginManager(self, self.mb, kwargs)

    def tick(self):
        &#34;&#34;&#34;
        Progresses the emulator ahead by one frame.

        To run the emulator in real-time, this will need to be called 60 times a second (for example in a while-loop).
        This function will block for roughly 16,67ms at a time, to not run faster than real-time, unless you specify
        otherwise with the `PyBoy.set_emulation_speed` method.

        _Open an issue on GitHub if you need finer control, and we will take a look at it._
        &#34;&#34;&#34;

        t_start = time.perf_counter() # Change to _ns when PyPy supports it
        self._handle_events(self.events)
        t_pre = time.perf_counter()
        self.frame_count += 1
        if not self.paused:
            self.mb.tickframe()
        t_tick = time.perf_counter()
        self._post_tick()
        t_post = time.perf_counter()

        secs = t_pre-t_start
        self.avg_pre = 0.9 * self.avg_pre + 0.1 * secs

        secs = t_tick-t_pre
        self.avg_tick = 0.9 * self.avg_tick + 0.1 * secs

        secs = t_post-t_tick
        self.avg_post = 0.9 * self.avg_post + 0.1 * secs

        return self.done

    def _handle_events(self, events):
        # This feeds events into the tick-loop from the window. There might already be events in the list from the API.
        events = self.plugin_manager.handle_events(events)

        for event in events:
            if event == WindowEvent.QUIT:
                self.done = True
            elif event == WindowEvent.RELEASE_SPEED_UP:
                # Switch between unlimited and 1x real-time emulation speed
                self.target_emulationspeed = int(bool(self.target_emulationspeed) ^ True)
                logger.info(&#34;Speed limit: %s&#34; % self.target_emulationspeed)
            elif event == WindowEvent.STATE_SAVE:
                with open(self.gamerom_file + &#34;.state&#34;, &#34;wb&#34;) as f:
                    self.mb.save_state(IntIOWrapper(f))
            elif event == WindowEvent.STATE_LOAD:
                with open(self.gamerom_file + &#34;.state&#34;, &#34;rb&#34;) as f:
                    self.mb.load_state(IntIOWrapper(f))
            elif event == WindowEvent.PASS:
                pass # Used in place of None in Cython, when key isn&#39;t mapped to anything
            elif event == WindowEvent.PAUSE_TOGGLE:
                if self.paused:
                    self._unpause()
                else:
                    self._pause()
            elif event == WindowEvent.PAUSE:
                self._pause()
            elif event == WindowEvent.UNPAUSE:
                self._unpause()
            elif event == WindowEvent._INTERNAL_RENDERER_FLUSH:
                self.plugin_manager._post_tick_windows()
            else:
                self.mb.buttonevent(event)

    def _pause(self):
        if self.paused:
            return
        self.paused = True
        self.save_target_emulationspeed = self.target_emulationspeed
        self.target_emulationspeed = 1
        logger.info(&#34;Emulation paused!&#34;)
        self._update_window_title()

    def _unpause(self):
        if not self.paused:
            return
        self.paused = False
        self.target_emulationspeed = self.save_target_emulationspeed
        logger.info(&#34;Emulation unpaused!&#34;)
        self._update_window_title()

    def _post_tick(self):
        if self.frame_count % 60 == 0:
            self._update_window_title()
        self.plugin_manager.post_tick()
        self.plugin_manager.frame_limiter(self.target_emulationspeed)

        # Prepare an empty list, as the API might be used to send in events between ticks
        self.events = []

    def _update_window_title(self):
        avg_emu = self.avg_pre + self.avg_tick + self.avg_post
        self.window_title = &#34;CPU/frame: %0.2f%%&#34; % ((self.avg_pre + self.avg_tick)/SPF*100)
        self.window_title += &#34; Emulation: x%d&#34; % (round(SPF/avg_emu) if avg_emu != 0 else 0)
        if self.paused:
            self.window_title += &#34;[PAUSED]&#34;
        self.window_title += self.plugin_manager.window_title()
        self.plugin_manager._set_title()

    def __del__(self):
        self.stop(save=False)

    def stop(self, save=True):
        &#34;&#34;&#34;
        Gently stops the emulator and all sub-modules.

        Args:
            save (bool): Specify whether to save the game upon stopping. It will always be saved in a file next to the
                provided game-ROM.
        &#34;&#34;&#34;
        logger.info(&#34;###########################&#34;)
        logger.info(&#34;# Emulator is turning off #&#34;)
        logger.info(&#34;###########################&#34;)
        self.plugin_manager.stop()
        self.mb.stop(save)

    def _cpu_hitrate(self):
        logger.warning(&#34;You are calling an internal function. The output and the function is subject to change.&#34;)
        return self.mb.cpu.hitrate

    ###################################################################
    # Scripts and bot methods
    #

    def screen(self):
        &#34;&#34;&#34;
        Use this method to get a `pyboy.botsupport.screen.Screen` object. This can be used to get the screen buffer in
        a variety of formats.

        It&#39;s also here you can find the screen position (SCX, SCY, WX, WY) for each scan line in the screen buffer. See
        `pyboy.botsupport.screen.Screen.tilemap_position` for more information.

        Returns
        -------
        `pyboy.botsupport.screen.Screen`:
            A Screen object with helper functions for reading the screen buffer.
        &#34;&#34;&#34;
        return botsupport.screen.Screen(self.mb)

    def memory_value(self, addr):
        &#34;&#34;&#34;
        Reads a given memory address of the Game Boy&#39;s current memory state. This will not directly give you access to
        all switchable memory banks. Open an issue on GitHub if that is needed, or use `PyBoy.set_memory_value` to send
        MBC commands to the virtual cartridge.

        Returns
        -------
        int:
            An integer with the value of the memory address
        &#34;&#34;&#34;
        return self.mb.getitem(addr)

    def set_memory_value(self, addr, value):
        &#34;&#34;&#34;
        Write one byte to a given memory address of the Game Boy&#39;s current memory state.

        This will not directly give you access to all switchable memory banks. Open an issue on GitHub if that is
        needed, or use this function to send &#34;Memory Bank Controller&#34; (MBC) commands to the virtual cartridge. You can
        read about the MBC at [Pan Docs](http://bgb.bircd.org/pandocs.htm).

        Args:
            addr (int): Address to write the byte
            value (int): A byte of data
        &#34;&#34;&#34;
        self.mb.setitem(addr, value)

    def send_input(self, event):
        &#34;&#34;&#34;
        Send a single input to control the emulator. This is both Game Boy buttons and emulator controls.

        See `pyboy.WindowEvent` for which events to send.

        Args:
            event (pyboy.WindowEvent): The event to send
        &#34;&#34;&#34;
        self.events.append(WindowEvent(event))

    def sprite(self, sprite_index):
        &#34;&#34;&#34;
        Provides a `pyboy.botsupport.sprite.Sprite` object, which makes the OAM data more presentable. The given index
        corresponds to index of the sprite in the &#34;Object Attribute Memory&#34; (OAM).

        The Game Boy supports 40 sprites in total. Read more details about it, in the [Pan
        Docs](http://bgb.bircd.org/pandocs.htm).

        Args:
            index (int): Sprite index from 0 to 39.
        Returns
        -------
        `pyboy.botsupport.sprite.Sprite`:
            Sprite corresponding to the given index.
        &#34;&#34;&#34;
        return botsupport.Sprite(self.mb, sprite_index)

    def sprite_by_tile_identifier(self, tile_identifiers, on_screen=True):
        &#34;&#34;&#34;
        Provided a list of tile identifiers, this function will find all occurrences of sprites using the tile
        identifiers and return the sprite indexes where each identifier is found. Use the sprite indexes in the
        `pyboy.PyBoy.sprite` function to get a `pyboy.botsupport.sprite.Sprite` object.

        Example:
        ```
        &gt;&gt;&gt; print(pyboy.sprite_by_tile_identifier([43, 123]))
        [[0, 2, 4], []]
        ```

        Meaning, that tile identifier `43` is found at the sprite indexes: 0, 2, and 4, while tile identifier
        `123` was not found anywhere.

        Args:
            identifiers (list): List of tile identifiers (int)
            on_screen (bool): Require that the matched sprite is on screen

        Returns
        -------
        list:
            list of sprite matches for every tile identifier in the input
        &#34;&#34;&#34;

        matches = []
        for i in tile_identifiers:
            match = []
            for s in range(botsupport.constants.SPRITES):
                sprite = botsupport.sprite.Sprite(self.mb, s)
                for t in sprite.tiles:
                    if t.tile_identifier == i and sprite.on_screen:
                        match.append(s)
            matches.append(match)
        return matches

    def tile(self, identifier):
        &#34;&#34;&#34;
        The Game Boy can have 384 tiles loaded in memory at once. Use this method to get a
        `pyboy.botsupport.tile.Tile`-object for given identifier.

        The identifier is a PyBoy construct, which unifies two different scopes of indexes in the Game Boy hardware. See
        the `pyboy.botsupport.tile.Tile` object for more information.

        Returns
        -------
        `pyboy.botsupport.tile.Tile`:
            A Tile object for the given identifier.
        &#34;&#34;&#34;
        return botsupport.Tile(self.mb, identifier=identifier)

    def tilemap_background(self):
        &#34;&#34;&#34;
        The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
        for the _background_ tiles. The game chooses whether it wants to use the low or the high tilemap.

        Read more details about it, in the [Pan Docs](http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps).

        Returns
        -------
        `pyboy.botsupport.tilemap.TileMap`:
            A TileMap object for the tile map.
        &#34;&#34;&#34;
        return botsupport.TileMap(self.mb, &#34;BACKGROUND&#34;)

    def tilemap_window(self):
        &#34;&#34;&#34;
        The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
        for the _window_ tiles. The game chooses whether it wants to use the low or the high tilemap.

        Read more details about it, in the [Pan Docs](http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps).

        Returns
        -------
        `pyboy.botsupport.tilemap.TileMap`:
            A TileMap object for the tile map.
        &#34;&#34;&#34;
        return botsupport.TileMap(self.mb, &#34;WINDOW&#34;)

    def save_state(self, file_like_object):
        &#34;&#34;&#34;
        Saves the complete state of the emulator. It can be called at any time, and enable you to revert any progress in
        a game.

        You can either save it to a file, or in-memory. The following two examples will provide the file handle in each
        case. Remember to `seek` the in-memory buffer to the beginning before calling `PyBoy.load_state`:

            # Save to file
            file_like_object = open(&#34;state_file.state&#34;, &#34;wb&#34;)

            # Save to memory
            import io
            file_like_object = io.BytesIO()
            file_like_object.seek(0)

        Args:
            file_like_object (io.BufferedIOBase): A file-like object for which to write the emulator state.
        &#34;&#34;&#34;

        if isinstance(file_like_object, str):
            raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

        self.mb.save_state(IntIOWrapper(file_like_object))

    def load_state(self, file_like_object):
        &#34;&#34;&#34;
        Restores the complete state of the emulator. It can be called at any time, and enable you to revert any progress
        in a game.

        You can either load it from a file, or from memory. See `PyBoy.save_state` for how to save the state, before you
        can load it here.

        To load a file, remember to load it as bytes:

            # Load file
            file_like_object = open(&#34;state_file.state&#34;, &#34;rb&#34;)


        Args:
            file_like_object (io.BufferedIOBase): A file-like object for which to read the emulator state.
        &#34;&#34;&#34;

        if isinstance(file_like_object, str):
            raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

        self.mb.load_state(IntIOWrapper(file_like_object))

    def _serial(self):
        &#34;&#34;&#34;
        Provides all data that has been sent over the serial port since last call to this function.

        Returns
        -------
        str :
            Buffer data
        &#34;&#34;&#34;
        return self.mb.getserial()

    def set_emulation_speed(self, target_speed):
        &#34;&#34;&#34;
        Set the target emulation speed. It might loose accuracy of keeping the exact speed, when using a high
        `target_speed`.

        The speed is defined as a multiple of real-time. I.e `target_speed=2` is double speed.

        A `target_speed` of `0` means unlimited. I.e. fastest possible execution.

        Args:
            target_speed (int): Target emulation speed as multiplier of real-time.
        &#34;&#34;&#34;
        if target_speed &gt; 5:
            logger.warning(&#34;The emulation speed might not be accurate when speed-target is higher than 5&#34;)
        self.target_emulationspeed = target_speed

    def cartridge_title(self):
        &#34;&#34;&#34;
        Get the title stored on the currently loaded cartridge ROM. The title is all upper-case ASCII and may
        have been truncated to 11 characters.

        Returns
        -------
        str :
            Game title
        &#34;&#34;&#34;
        return self.mb.cartridge.gamename</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyboy.pyboy.PyBoy.cartridge_title"><code class="name flex">
<span>def <span class="ident">cartridge_title</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the title stored on the currently loaded cartridge ROM. The title is all upper-case ASCII and may
have been truncated to 11 characters.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> :</dt>
<dd>Game title</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cartridge_title(self):
    &#34;&#34;&#34;
    Get the title stored on the currently loaded cartridge ROM. The title is all upper-case ASCII and may
    have been truncated to 11 characters.

    Returns
    -------
    str :
        Game title
    &#34;&#34;&#34;
    return self.mb.cartridge.gamename</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.load_state"><code class="name flex">
<span>def <span class="ident">load_state</span></span>(<span>self, file_like_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Restores the complete state of the emulator. It can be called at any time, and enable you to revert any progress
in a game.</p>
<p>You can either load it from a file, or from memory. See <a title="pyboy.pyboy.PyBoy.save_state" href="#pyboy.pyboy.PyBoy.save_state"><code>PyBoy.save_state()</code></a> for how to save the state, before you
can load it here.</p>
<p>To load a file, remember to load it as bytes:</p>
<pre><code># Load file
file_like_object = open("state_file.state", "rb")
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_like_object</code></strong> :&ensp;<code>io.BufferedIOBase</code></dt>
<dd>A file-like object for which to read the emulator state.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load_state(self, file_like_object):
    &#34;&#34;&#34;
    Restores the complete state of the emulator. It can be called at any time, and enable you to revert any progress
    in a game.

    You can either load it from a file, or from memory. See `PyBoy.save_state` for how to save the state, before you
    can load it here.

    To load a file, remember to load it as bytes:

        # Load file
        file_like_object = open(&#34;state_file.state&#34;, &#34;rb&#34;)


    Args:
        file_like_object (io.BufferedIOBase): A file-like object for which to read the emulator state.
    &#34;&#34;&#34;

    if isinstance(file_like_object, str):
        raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

    self.mb.load_state(IntIOWrapper(file_like_object))</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.memory_value"><code class="name flex">
<span>def <span class="ident">memory_value</span></span>(<span>self, addr)</span>
</code></dt>
<dd>
<section class="desc"><p>Reads a given memory address of the Game Boy's current memory state. This will not directly give you access to
all switchable memory banks. Open an issue on GitHub if that is needed, or use <a title="pyboy.pyboy.PyBoy.set_memory_value" href="#pyboy.pyboy.PyBoy.set_memory_value"><code>PyBoy.set_memory_value()</code></a> to send
MBC commands to the virtual cartridge.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code>:</dt>
<dd>An integer with the value of the memory address</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def memory_value(self, addr):
    &#34;&#34;&#34;
    Reads a given memory address of the Game Boy&#39;s current memory state. This will not directly give you access to
    all switchable memory banks. Open an issue on GitHub if that is needed, or use `PyBoy.set_memory_value` to send
    MBC commands to the virtual cartridge.

    Returns
    -------
    int:
        An integer with the value of the memory address
    &#34;&#34;&#34;
    return self.mb.getitem(addr)</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.save_state"><code class="name flex">
<span>def <span class="ident">save_state</span></span>(<span>self, file_like_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves the complete state of the emulator. It can be called at any time, and enable you to revert any progress in
a game.</p>
<p>You can either save it to a file, or in-memory. The following two examples will provide the file handle in each
case. Remember to <code>seek</code> the in-memory buffer to the beginning before calling <a title="pyboy.pyboy.PyBoy.load_state" href="#pyboy.pyboy.PyBoy.load_state"><code>PyBoy.load_state()</code></a>:</p>
<pre><code># Save to file
file_like_object = open("state_file.state", "wb")

# Save to memory
import io
file_like_object = io.BytesIO()
file_like_object.seek(0)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_like_object</code></strong> :&ensp;<code>io.BufferedIOBase</code></dt>
<dd>A file-like object for which to write the emulator state.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save_state(self, file_like_object):
    &#34;&#34;&#34;
    Saves the complete state of the emulator. It can be called at any time, and enable you to revert any progress in
    a game.

    You can either save it to a file, or in-memory. The following two examples will provide the file handle in each
    case. Remember to `seek` the in-memory buffer to the beginning before calling `PyBoy.load_state`:

        # Save to file
        file_like_object = open(&#34;state_file.state&#34;, &#34;wb&#34;)

        # Save to memory
        import io
        file_like_object = io.BytesIO()
        file_like_object.seek(0)

    Args:
        file_like_object (io.BufferedIOBase): A file-like object for which to write the emulator state.
    &#34;&#34;&#34;

    if isinstance(file_like_object, str):
        raise Exception(&#34;String not allowed. Did you specify a filepath instead of a file-like object?&#34;)

    self.mb.save_state(IntIOWrapper(file_like_object))</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.screen"><code class="name flex">
<span>def <span class="ident">screen</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Use this method to get a <a title="pyboy.botsupport.screen.Screen" href="botsupport/screen.html#pyboy.botsupport.screen.Screen"><code>Screen</code></a> object. This can be used to get the screen buffer in
a variety of formats.</p>
<p>It's also here you can find the screen position (SCX, SCY, WX, WY) for each scan line in the screen buffer. See
<a title="pyboy.botsupport.screen.Screen.tilemap_position" href="botsupport/screen.html#pyboy.botsupport.screen.Screen.tilemap_position"><code>Screen.tilemap_position()</code></a> for more information.</p>
<h2 id="returns">Returns</h2>
<p><a title="pyboy.botsupport.screen.Screen" href="botsupport/screen.html#pyboy.botsupport.screen.Screen"><code>Screen</code></a>:
A Screen object with helper functions for reading the screen buffer.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def screen(self):
    &#34;&#34;&#34;
    Use this method to get a `pyboy.botsupport.screen.Screen` object. This can be used to get the screen buffer in
    a variety of formats.

    It&#39;s also here you can find the screen position (SCX, SCY, WX, WY) for each scan line in the screen buffer. See
    `pyboy.botsupport.screen.Screen.tilemap_position` for more information.

    Returns
    -------
    `pyboy.botsupport.screen.Screen`:
        A Screen object with helper functions for reading the screen buffer.
    &#34;&#34;&#34;
    return botsupport.screen.Screen(self.mb)</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.send_input"><code class="name flex">
<span>def <span class="ident">send_input</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<section class="desc"><p>Send a single input to control the emulator. This is both Game Boy buttons and emulator controls.</p>
<p>See <a title="pyboy.WindowEvent" href="index.html#pyboy.WindowEvent"><code>WindowEvent</code></a> for which events to send.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<a title="pyboy.WindowEvent" href="index.html#pyboy.WindowEvent"><code>WindowEvent</code></a></dt>
<dd>The event to send</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def send_input(self, event):
    &#34;&#34;&#34;
    Send a single input to control the emulator. This is both Game Boy buttons and emulator controls.

    See `pyboy.WindowEvent` for which events to send.

    Args:
        event (pyboy.WindowEvent): The event to send
    &#34;&#34;&#34;
    self.events.append(WindowEvent(event))</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.set_emulation_speed"><code class="name flex">
<span>def <span class="ident">set_emulation_speed</span></span>(<span>self, target_speed)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the target emulation speed. It might loose accuracy of keeping the exact speed, when using a high
<code>target_speed</code>.</p>
<p>The speed is defined as a multiple of real-time. I.e <code>target_speed=2</code> is double speed.</p>
<p>A <code>target_speed</code> of <code>0</code> means unlimited. I.e. fastest possible execution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_speed</code></strong> :&ensp;<code>int</code></dt>
<dd>Target emulation speed as multiplier of real-time.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_emulation_speed(self, target_speed):
    &#34;&#34;&#34;
    Set the target emulation speed. It might loose accuracy of keeping the exact speed, when using a high
    `target_speed`.

    The speed is defined as a multiple of real-time. I.e `target_speed=2` is double speed.

    A `target_speed` of `0` means unlimited. I.e. fastest possible execution.

    Args:
        target_speed (int): Target emulation speed as multiplier of real-time.
    &#34;&#34;&#34;
    if target_speed &gt; 5:
        logger.warning(&#34;The emulation speed might not be accurate when speed-target is higher than 5&#34;)
    self.target_emulationspeed = target_speed</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.set_memory_value"><code class="name flex">
<span>def <span class="ident">set_memory_value</span></span>(<span>self, addr, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Write one byte to a given memory address of the Game Boy's current memory state.</p>
<p>This will not directly give you access to all switchable memory banks. Open an issue on GitHub if that is
needed, or use this function to send "Memory Bank Controller" (MBC) commands to the virtual cartridge. You can
read about the MBC at <a href="http://bgb.bircd.org/pandocs.htm">Pan Docs</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>addr</code></strong> :&ensp;<code>int</code></dt>
<dd>Address to write the byte</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>A byte of data</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_memory_value(self, addr, value):
    &#34;&#34;&#34;
    Write one byte to a given memory address of the Game Boy&#39;s current memory state.

    This will not directly give you access to all switchable memory banks. Open an issue on GitHub if that is
    needed, or use this function to send &#34;Memory Bank Controller&#34; (MBC) commands to the virtual cartridge. You can
    read about the MBC at [Pan Docs](http://bgb.bircd.org/pandocs.htm).

    Args:
        addr (int): Address to write the byte
        value (int): A byte of data
    &#34;&#34;&#34;
    self.mb.setitem(addr, value)</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.sprite"><code class="name flex">
<span>def <span class="ident">sprite</span></span>(<span>self, sprite_index)</span>
</code></dt>
<dd>
<section class="desc"><p>Provides a <a title="pyboy.botsupport.sprite.Sprite" href="botsupport/sprite.html#pyboy.botsupport.sprite.Sprite"><code>Sprite</code></a> object, which makes the OAM data more presentable. The given index
corresponds to index of the sprite in the "Object Attribute Memory" (OAM).</p>
<p>The Game Boy supports 40 sprites in total. Read more details about it, in the <a href="http://bgb.bircd.org/pandocs.htm">Pan
Docs</a>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>Sprite index from 0 to 39.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><a title="pyboy.botsupport.sprite.Sprite" href="botsupport/sprite.html#pyboy.botsupport.sprite.Sprite"><code>Sprite</code></a>:
Sprite corresponding to the given index.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def sprite(self, sprite_index):
    &#34;&#34;&#34;
    Provides a `pyboy.botsupport.sprite.Sprite` object, which makes the OAM data more presentable. The given index
    corresponds to index of the sprite in the &#34;Object Attribute Memory&#34; (OAM).

    The Game Boy supports 40 sprites in total. Read more details about it, in the [Pan
    Docs](http://bgb.bircd.org/pandocs.htm).

    Args:
        index (int): Sprite index from 0 to 39.
    Returns
    -------
    `pyboy.botsupport.sprite.Sprite`:
        Sprite corresponding to the given index.
    &#34;&#34;&#34;
    return botsupport.Sprite(self.mb, sprite_index)</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.sprite_by_tile_identifier"><code class="name flex">
<span>def <span class="ident">sprite_by_tile_identifier</span></span>(<span>self, tile_identifiers, on_screen=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Provided a list of tile identifiers, this function will find all occurrences of sprites using the tile
identifiers and return the sprite indexes where each identifier is found. Use the sprite indexes in the
<a title="pyboy.PyBoy.sprite" href="index.html#pyboy.PyBoy.sprite"><code>PyBoy.sprite()</code></a> function to get a <a title="pyboy.botsupport.sprite.Sprite" href="botsupport/sprite.html#pyboy.botsupport.sprite.Sprite"><code>Sprite</code></a> object.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; print(pyboy.sprite_by_tile_identifier([43, 123]))
[[0, 2, 4], []]
</code></pre>
<p>Meaning, that tile identifier <code>43</code> is found at the sprite indexes: 0, 2, and 4, while tile identifier
<code>123</code> was not found anywhere.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>identifiers</code></strong> :&ensp;<code>list</code></dt>
<dd>List of tile identifiers (int)</dd>
<dt><strong><code>on_screen</code></strong> :&ensp;<code>bool</code></dt>
<dd>Require that the matched sprite is on screen</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code>:</dt>
<dd>list of sprite matches for every tile identifier in the input</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def sprite_by_tile_identifier(self, tile_identifiers, on_screen=True):
    &#34;&#34;&#34;
    Provided a list of tile identifiers, this function will find all occurrences of sprites using the tile
    identifiers and return the sprite indexes where each identifier is found. Use the sprite indexes in the
    `pyboy.PyBoy.sprite` function to get a `pyboy.botsupport.sprite.Sprite` object.

    Example:
    ```
    &gt;&gt;&gt; print(pyboy.sprite_by_tile_identifier([43, 123]))
    [[0, 2, 4], []]
    ```

    Meaning, that tile identifier `43` is found at the sprite indexes: 0, 2, and 4, while tile identifier
    `123` was not found anywhere.

    Args:
        identifiers (list): List of tile identifiers (int)
        on_screen (bool): Require that the matched sprite is on screen

    Returns
    -------
    list:
        list of sprite matches for every tile identifier in the input
    &#34;&#34;&#34;

    matches = []
    for i in tile_identifiers:
        match = []
        for s in range(botsupport.constants.SPRITES):
            sprite = botsupport.sprite.Sprite(self.mb, s)
            for t in sprite.tiles:
                if t.tile_identifier == i and sprite.on_screen:
                    match.append(s)
        matches.append(match)
    return matches</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self, save=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Gently stops the emulator and all sub-modules.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code></dt>
<dd>Specify whether to save the game upon stopping. It will always be saved in a file next to the
provided game-ROM.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def stop(self, save=True):
    &#34;&#34;&#34;
    Gently stops the emulator and all sub-modules.

    Args:
        save (bool): Specify whether to save the game upon stopping. It will always be saved in a file next to the
            provided game-ROM.
    &#34;&#34;&#34;
    logger.info(&#34;###########################&#34;)
    logger.info(&#34;# Emulator is turning off #&#34;)
    logger.info(&#34;###########################&#34;)
    self.plugin_manager.stop()
    self.mb.stop(save)</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.tick"><code class="name flex">
<span>def <span class="ident">tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Progresses the emulator ahead by one frame.</p>
<p>To run the emulator in real-time, this will need to be called 60 times a second (for example in a while-loop).
This function will block for roughly 16,67ms at a time, to not run faster than real-time, unless you specify
otherwise with the <a title="pyboy.pyboy.PyBoy.set_emulation_speed" href="#pyboy.pyboy.PyBoy.set_emulation_speed"><code>PyBoy.set_emulation_speed()</code></a> method.</p>
<p><em>Open an issue on GitHub if you need finer control, and we will take a look at it.</em></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def tick(self):
    &#34;&#34;&#34;
    Progresses the emulator ahead by one frame.

    To run the emulator in real-time, this will need to be called 60 times a second (for example in a while-loop).
    This function will block for roughly 16,67ms at a time, to not run faster than real-time, unless you specify
    otherwise with the `PyBoy.set_emulation_speed` method.

    _Open an issue on GitHub if you need finer control, and we will take a look at it._
    &#34;&#34;&#34;

    t_start = time.perf_counter() # Change to _ns when PyPy supports it
    self._handle_events(self.events)
    t_pre = time.perf_counter()
    self.frame_count += 1
    if not self.paused:
        self.mb.tickframe()
    t_tick = time.perf_counter()
    self._post_tick()
    t_post = time.perf_counter()

    secs = t_pre-t_start
    self.avg_pre = 0.9 * self.avg_pre + 0.1 * secs

    secs = t_tick-t_pre
    self.avg_tick = 0.9 * self.avg_tick + 0.1 * secs

    secs = t_post-t_tick
    self.avg_post = 0.9 * self.avg_post + 0.1 * secs

    return self.done</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.tile"><code class="name flex">
<span>def <span class="ident">tile</span></span>(<span>self, identifier)</span>
</code></dt>
<dd>
<section class="desc"><p>The Game Boy can have 384 tiles loaded in memory at once. Use this method to get a
<a title="pyboy.botsupport.tile.Tile" href="botsupport/tile.html#pyboy.botsupport.tile.Tile"><code>Tile</code></a>-object for given identifier.</p>
<p>The identifier is a PyBoy construct, which unifies two different scopes of indexes in the Game Boy hardware. See
the <a title="pyboy.botsupport.tile.Tile" href="botsupport/tile.html#pyboy.botsupport.tile.Tile"><code>Tile</code></a> object for more information.</p>
<h2 id="returns">Returns</h2>
<p><a title="pyboy.botsupport.tile.Tile" href="botsupport/tile.html#pyboy.botsupport.tile.Tile"><code>Tile</code></a>:
A Tile object for the given identifier.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def tile(self, identifier):
    &#34;&#34;&#34;
    The Game Boy can have 384 tiles loaded in memory at once. Use this method to get a
    `pyboy.botsupport.tile.Tile`-object for given identifier.

    The identifier is a PyBoy construct, which unifies two different scopes of indexes in the Game Boy hardware. See
    the `pyboy.botsupport.tile.Tile` object for more information.

    Returns
    -------
    `pyboy.botsupport.tile.Tile`:
        A Tile object for the given identifier.
    &#34;&#34;&#34;
    return botsupport.Tile(self.mb, identifier=identifier)</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.tilemap_background"><code class="name flex">
<span>def <span class="ident">tilemap_background</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
for the <em>background</em> tiles. The game chooses whether it wants to use the low or the high tilemap.</p>
<p>Read more details about it, in the <a href="http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps">Pan Docs</a>.</p>
<h2 id="returns">Returns</h2>
<p><a title="pyboy.botsupport.tilemap.TileMap" href="botsupport/tilemap.html#pyboy.botsupport.tilemap.TileMap"><code>TileMap</code></a>:
A TileMap object for the tile map.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def tilemap_background(self):
    &#34;&#34;&#34;
    The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
    for the _background_ tiles. The game chooses whether it wants to use the low or the high tilemap.

    Read more details about it, in the [Pan Docs](http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps).

    Returns
    -------
    `pyboy.botsupport.tilemap.TileMap`:
        A TileMap object for the tile map.
    &#34;&#34;&#34;
    return botsupport.TileMap(self.mb, &#34;BACKGROUND&#34;)</code></pre>
</details>
</dd>
<dt id="pyboy.pyboy.PyBoy.tilemap_window"><code class="name flex">
<span>def <span class="ident">tilemap_window</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
for the <em>window</em> tiles. The game chooses whether it wants to use the low or the high tilemap.</p>
<p>Read more details about it, in the <a href="http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps">Pan Docs</a>.</p>
<h2 id="returns">Returns</h2>
<p><a title="pyboy.botsupport.tilemap.TileMap" href="botsupport/tilemap.html#pyboy.botsupport.tilemap.TileMap"><code>TileMap</code></a>:
A TileMap object for the tile map.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def tilemap_window(self):
    &#34;&#34;&#34;
    The Game Boy uses two tile maps at the same time to draw graphics on the screen. This method will provide one
    for the _window_ tiles. The game chooses whether it wants to use the low or the high tilemap.

    Read more details about it, in the [Pan Docs](http://bgb.bircd.org/pandocs.htm#vrambackgroundmaps).

    Returns
    -------
    `pyboy.botsupport.tilemap.TileMap`:
        A TileMap object for the tile map.
    &#34;&#34;&#34;
    return botsupport.TileMap(self.mb, &#34;WINDOW&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyboy" href="index.html">pyboy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyboy.pyboy.PyBoy" href="#pyboy.pyboy.PyBoy">PyBoy</a></code></h4>
<ul class="">
<li><code><a title="pyboy.pyboy.PyBoy.cartridge_title" href="#pyboy.pyboy.PyBoy.cartridge_title">cartridge_title</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.load_state" href="#pyboy.pyboy.PyBoy.load_state">load_state</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.memory_value" href="#pyboy.pyboy.PyBoy.memory_value">memory_value</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.save_state" href="#pyboy.pyboy.PyBoy.save_state">save_state</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.screen" href="#pyboy.pyboy.PyBoy.screen">screen</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.send_input" href="#pyboy.pyboy.PyBoy.send_input">send_input</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.set_emulation_speed" href="#pyboy.pyboy.PyBoy.set_emulation_speed">set_emulation_speed</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.set_memory_value" href="#pyboy.pyboy.PyBoy.set_memory_value">set_memory_value</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.sprite" href="#pyboy.pyboy.PyBoy.sprite">sprite</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.sprite_by_tile_identifier" href="#pyboy.pyboy.PyBoy.sprite_by_tile_identifier">sprite_by_tile_identifier</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.stop" href="#pyboy.pyboy.PyBoy.stop">stop</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.tick" href="#pyboy.pyboy.PyBoy.tick">tick</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.tile" href="#pyboy.pyboy.PyBoy.tile">tile</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.tilemap_background" href="#pyboy.pyboy.PyBoy.tilemap_background">tilemap_background</a></code></li>
<li><code><a title="pyboy.pyboy.PyBoy.tilemap_window" href="#pyboy.pyboy.PyBoy.tilemap_window">tilemap_window</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>