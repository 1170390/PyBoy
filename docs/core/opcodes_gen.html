<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>pyboy.core.opcodes_gen API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyboy.core.opcodes_gen</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#
# License: See LICENSE file
# GitHub: https://github.com/Baekalfen/PyBoy
#


import re
from html.parser import HTMLParser
from urllib.request import urlopen

destination = &#34;opcodes.py&#34;
pxd_destination = &#34;opcodes.pxd&#34;

warning = &#34;&#34;&#34;
# THIS FILE IS AUTO-GENERATED!!!
# DO NOT MODIFY THIS FILE.
# CHANGES TO THE CODE SHOULD BE MADE IN &#39;opcodes_gen.py&#39;.
&#34;&#34;&#34;

imports = &#34;&#34;&#34;
import array

FLAGC, FLAGH, FLAGN, FLAGZ = range(4, 8)


&#34;&#34;&#34;

cimports = &#34;&#34;&#34;
cimport cpu
cimport cython
from libc.stdint cimport uint8_t, uint16_t, uint32_t


cdef (int, int) _dummy_declaration
cdef (int, int, int, int) _dummy_declaration2

cdef uint16_t FLAGC, FLAGH, FLAGN, FLAGZ
cdef uint8_t[512] OPCODE_LENGTHS
cdef uint16_t opcode_length(uint16_t)
@cython.locals(v=cython.int, a=cython.int, b=cython.int, pc=cython.ushort)
cdef int execute_opcode(cpu.CPU, uint16_t)

cdef uint8_t no_opcode(cpu.CPU) except -1
&#34;&#34;&#34;


def inline_signed_int8(arg):
    return &#34;(({} ^ 0x80) - 0x80)&#34;.format(arg)


opcodes = []


class MyHTMLParser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)

        self.counter = 0
        self.tagstack = []

        self.cell_lines = []
        self.stop = False
        self._attrs = None
        self.founddata = False

    def handle_starttag(self, tag, attrs):
        if tag != &#34;br&#34;:
            self.founddata = False
            self._attrs = attrs
            self.tagstack.append(tag)

    def handle_endtag(self, tag):
        if not self.founddata and self.tagstack[-1] == &#34;td&#34; and self.counter % 0x100 != 0:
            self.counter += 1
            opcodes.append(None) # Blank operations
        self.tagstack.pop()

    def handle_data(self, data):
        if self.stop or len(self.tagstack) == 0:
            return

        self.founddata = True

        if self.tagstack[-1] == &#34;td&#34;:
            self.cell_lines.append(data)

            if len(self.cell_lines) == 4:
                opcodes.append(self.make_opcode(
                    self.cell_lines,
                    (&#34;bgcolor&#34;, &#34;#ccffcc&#34;) in self._attrs or
                    (&#34;bgcolor&#34;, &#34;#ffcccc&#34;) in self._attrs))
                self.counter += 1
                self.cell_lines = []

        if self.counter == 0x200:
            self.stop = True

    def make_opcode(self, lines, bit16):
        opcode = self.counter
        flags = lines.pop()
        cycles = lines.pop()
        length = lines.pop()
        name = lines.pop()

        return OpcodeData(opcode, name, length, cycles, bit16, *flags.split())


class Operand:
    def __init__(self, operand):
        self.postoperation = None
        self.pointer = False
        self.highpointer = False
        self.immediate = False
        self.signed = False
        self.is16bit = False
        self.flag = False
        self.operand = operand
        self.codegen(False)

    @property
    def set(self):
        return self.codegen(True)

    @property
    def get(self):
        return self.codegen(False)

    def codegen(self, assign, operand=None):
        if operand is None:
            operand = self.operand

        if operand == &#34;(C)&#34;:
            self.highpointer = True
            if assign:
                return &#34;cpu.mb.setitem(0xFF00 + cpu.C, %s)&#34;
            else:
                return &#34;cpu.mb.getitem(0xFF00 + cpu.C)&#34;

        elif operand == &#34;SP+r8&#34;:
            self.immediate = True
            self.signed = True

            # post operation set in LD handler!
            return &#34;cpu.SP + &#34; + inline_signed_int8(&#34;v&#34;)

        elif operand.startswith(&#39;(&#39;) and operand.endswith(&#39;)&#39;):
            self.pointer = True
            if assign:
                code = &#34;cpu.mb.setitem(%s&#34; % self.codegen(False, operand=re.search(
                    r&#39;\(([a-zA-Z]+\d*)[\+-]?\)&#39;, operand).group(1)) + &#34;, %s)&#34;
            else:
                code = &#34;cpu.mb.getitem(%s)&#34; % self.codegen(False, operand=re.search(
                    r&#39;\(([a-zA-Z]+\d*)[\+-]?\)&#39;, operand).group(1))

            if &#39;-&#39; in operand or &#39;+&#39; in operand:
                # TODO: Replace with opcode 23 (INC HL)?
                self.postoperation = &#34;cpu.HL %s= 1&#34; % operand[-2]

            return code

        # Sadly, there is an overlap between the register &#39;C&#39; and to
        # check for the carry flag &#39;C&#39;.
        elif operand in [
                &#39;A&#39;, &#39;F&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, # registers
                &#39;SP&#39;, &#39;PC&#39;, &#39;HL&#39;]:             # double registers
            if assign:
                return &#34;cpu.&#34; + operand + &#34; = %s&#34;
            else:
                return &#34;cpu.&#34; + operand

        elif operand == &#39;H&#39;:
            if assign:
                return &#34;cpu.HL = (cpu.HL &amp; 0x00FF) | (%s &lt;&lt; 8)&#34;
            else:
                return &#34;(cpu.HL &gt;&gt; 8)&#34;

        elif operand == &#39;L&#39;:
            if assign:
                return &#34;cpu.HL = (cpu.HL &amp; 0xFF00) | (%s &amp; 0xFF)&#34;
            else:
                return &#34;(cpu.HL &amp; 0xFF)&#34;

        elif operand in [&#39;AF&#39;, &#39;BC&#39;, &#39;DE&#39;]:
            if assign:
                return &#34;cpu.set_&#34; + operand.lower() + &#34;(%s)&#34;
            else:
                return &#34;((cpu.&#34; + operand[0] + &#34; &lt;&lt; 8) + cpu.&#34; + operand[1] + &#34;)&#34;

        elif operand in [&#39;Z&#39;, &#39;C&#39;, &#39;NZ&#39;, &#39;NC&#39;]: # flags
            assert not assign
            self.flag = True
            return &#34;cpu.f_&#34; + operand.lower() + &#34;()&#34;

        elif operand in [&#39;d8&#39;, &#39;d16&#39;, &#39;a8&#39;, &#39;a16&#39;, &#39;r8&#39;]:
            assert not assign
            code = &#34;v&#34;
            self.immediate = True

            if operand == &#39;r8&#39;:
                code = inline_signed_int8(code)
                self.signed = True
            elif operand == &#39;a8&#39;:
                code += &#34; + 0xFF00&#34;
                self.highpointer = True
            return code

        else:
            raise ValueError(&#34;Didn&#39;t match symbol: %s&#34; % operand)


class Literal:
    def __init__(self, value):
        if isinstance(value, str) and value.find(&#39;H&#39;) &gt; 0:
            self.value = int(value[:-1], 16)
        else:
            self.value = value
        self.code = str(self.value)
        self.immediate = False

    @property
    def get(self):
        return self.code


class Code:
    def __init__(self, function_name, opcode, name, takes_immediate, length, cycles,
                 branch_op=False):
        self.function_name = function_name
        self.opcode = opcode
        self.name = name
        self.cycles = cycles
        self.takes_immediate = takes_immediate
        self.length = length
        self.lines = []
        self.branch_op = branch_op

    def addline(self, line):
        self.lines.append(line)

    def addlines(self, lines):
        for l in lines:
            self.lines.append(l)

    def getcode(self):
        code = &#34;&#34;
        code += [&#34;def %s_%0.2X(cpu): # %0.2X %s&#34;
                 % (self.function_name, self.opcode, self.opcode, self.name),
                 &#34;def %s_%0.2X(cpu, v): # %0.2X %s&#34;
                 % (self.function_name, self.opcode, self.opcode, self.name)][self.takes_immediate]
        code += &#34;\n\t&#34;

        if not self.branch_op:
            self.lines.append(&#34;cpu.PC += %d&#34; % self.length)
            self.lines.append(&#34;return &#34; + self.cycles[0]) # Choose the 0th cycle count

        code += &#34;\n\t&#34;.join(self.lines)

        pxd = [&#34;cdef uint8_t %s_%0.2X(cpu.CPU) except -1 # %0.2X %s&#34;
               % (self.function_name, self.opcode, self.opcode, self.name),
               # TODO: Differentiate between 16-bit values
               # (01,11,21,31 ops) and 8-bit values for &#39;v&#39;
               &#34;cdef uint8_t %s_%0.2X(cpu.CPU, int v) except -1 # %0.2X %s&#34;
               % (self.function_name, self.opcode, self.opcode, self.name)][self.takes_immediate]

        if self.opcode == 0x27:
            pxd = &#34;@cython.locals(v=int, flag=uint8_t, t=int, corr=ushort)\n&#34; + pxd
        else:
            pxd = &#34;@cython.locals(v=int, flag=uint8_t, t=int)\n&#34; + pxd

        return (pxd, code)


class OpcodeData:
    def __init__(self, opcode, name, length, cycles, bit16, flag_z, flag_n, flag_h, flag_c):
        self.opcode = opcode
        self.name = name
        self.length = int(length)
        self.cycles = tuple(cycles.split(&#34;/&#34;))
        self.flag_z = flag_z
        self.flag_n = flag_n
        self.flag_h = flag_h
        self.flag_c = flag_c
        self.flags = tuple(enumerate([self.flag_c, self.flag_h, self.flag_n, self.flag_z]))
        self.is16bit = bit16

        # TODO: There&#39;s no need for this to be so explicit
        self.functionhandlers = {
            &#34;NOP&#34;    : self.NOP,
            &#34;HALT&#34;   : self.HALT,
            &#34;PREFIX&#34; : self.CB,
            &#34;EI&#34;     : self.EI,
            &#34;DI&#34;     : self.DI,
            &#34;STOP&#34;   : self.STOP,

            &#34;LD&#34;     : self.LD,
            &#34;LDH&#34;    : self.LDH,

            &#34;ADD&#34;    : self.ADD,
            &#34;SUB&#34;    : self.SUB,
            &#34;INC&#34;    : self.INC,
            &#34;DEC&#34;    : self.DEC,
            &#34;ADC&#34;    : self.ADC,
            &#34;SBC&#34;    : self.SBC,

            &#34;AND&#34;    : self.AND,
            &#34;OR&#34;     : self.OR,
            &#34;XOR&#34;    : self.XOR,
            &#34;CP&#34;     : self.CP,

            &#34;PUSH&#34;   : self.PUSH,
            &#34;POP&#34;    : self.POP,

            &#34;JP&#34;     : self.JP,
            &#34;JR&#34;     : self.JR,
            &#34;CALL&#34;   : self.CALL,
            &#34;RET&#34;    : self.RET,
            &#34;RETI&#34;   : self.RETI,
            &#34;RST&#34;    : self.RST,

            &#34;DAA&#34;    : self.DAA,
            &#34;SCF&#34;    : self.SCF,
            &#34;CCF&#34;    : self.CCF,
            &#34;CPL&#34;    : self.CPL,

            &#34;RLA&#34;    : self.RLA,
            &#34;RLCA&#34;   : self.RLCA,
            &#34;RLC&#34;    : self.RLC,
            &#34;RL&#34;     : self.RL,
            &#34;RRA&#34;    : self.RRA,
            &#34;RRCA&#34;   : self.RRCA,
            &#34;RRC&#34;    : self.RRC,
            &#34;RR&#34;     : self.RR,

            &#34;SLA&#34;    : self.SLA,
            &#34;SRA&#34;    : self.SRA,
            &#34;SWAP&#34;   : self.SWAP,
            &#34;SRL&#34;    : self.SRL,
            &#34;BIT&#34;    : self.BIT,
            &#34;RES&#34;    : self.RES,
            &#34;SET&#34;    : self.SET
        }

    def createfunction(self):
        text = self.functionhandlers[self.name.split()[0]]()
        # Compensate for CB operations being &#34;2 bytes long&#34;
        if self.opcode &gt; 0xFF:
            self.length -= 1
        return (self.length, &#34;%s_%0.2X&#34; % (self.name.split()[0], self.opcode), self.name), text

    # Special carry and half-carry for E8 and F8:
    # http://forums.nesdev.com/viewtopic.php?p=42138
    # Blargg: &#34;Both of these set carry and half-carry based on the low
    # byte of SP added to the UNSIGNED immediate byte. The Negative
    # and Zero flags are always cleared. They also calculate SP +
    # SIGNED immediate byte and put the result into SP or HL,
    # respectively.&#34;
    def handleflags16bit_E8_F8(self, r0, r1, op, carry=False):
        flagmask = sum(map(lambda nf: (nf[1] == &#34;-&#34;) &lt;&lt; (nf[0]+4), self.flags))

        # Only in case we do a dynamic operation, do we include the
        # following calculations
        if flagmask == 0b11110000:
            return [&#34;# No flag operations&#34;]

        lines = []
        # Sets the flags that always get set by operation
        lines.append(&#34;flag = &#34; + format(sum(map(lambda nf: (nf[1] == &#34;1&#34;) &lt;&lt; (nf[0]+4),
                                                self.flags)), &#34;#010b&#34;))

        # flag += (((cpu.SP &amp; 0xF) + (v &amp; 0xF)) &gt; 0xF) &lt;&lt; FLAGH
        if self.flag_h == &#34;H&#34;:
            c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
            lines.append(&#34;flag += (((%s &amp; 0xF) %s (%s &amp; 0xF)%s) &gt; 0xF) &lt;&lt; FLAGH&#34;
                         % (r0, op, r1, c))

        # flag += (((cpu.SP &amp; 0xFF) + (v &amp; 0xFF)) &gt; 0xFF) &lt;&lt; FLAGC
        if self.flag_c == &#34;C&#34;:
            lines.append(&#34;flag += (((%s &amp; 0xFF) %s (%s &amp; 0xFF)%s) &gt; 0xFF) &lt;&lt; FLAGC&#34;
                         % (r0, op, r1, c))

        # Clears all flags affected by the operation
        lines.append(&#34;cpu.F &amp;= &#34; + format(flagmask, &#34;#010b&#34;))
        lines.append(&#34;cpu.F |= flag&#34;)
        return lines

    def handleflags16bit(self, r0, r1, op, carry=False):
        flagmask = sum(map(lambda nf: (nf[1] == &#34;-&#34;) &lt;&lt; (nf[0]+4), self.flags))

        # Only in case we do a dynamic operation, do we include the
        # following calculations
        if flagmask == 0b11110000:
            return [&#34;# No flag operations&#34;]

        lines = []
        # Sets the ones that always get set by operation
        lines.append(&#34;flag = &#34; + format(sum(map(lambda nf: (nf[1] == &#34;1&#34;) &lt;&lt; (nf[0]+4),
                                                self.flags)), &#34;#010b&#34;))

        if self.flag_h == &#34;H&#34;:
            c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
            lines.append(&#34;flag += (((%s &amp; 0xFFF) %s (%s &amp; 0xFFF)%s) &gt; 0xFFF) &lt;&lt; FLAGH&#34;
                         % (r0, op, r1, c))

        if self.flag_c == &#34;C&#34;:
            lines.append(&#34;flag += (t &gt; 0xFFFF) &lt;&lt; FLAGC&#34;)

        # Clears all flags affected by the operation
        lines.append(&#34;cpu.F &amp;= &#34; + format(flagmask, &#34;#010b&#34;))
        lines.append(&#34;cpu.F |= flag&#34;)
        return lines

    def handleflags8bit(self, r0, r1, op, carry=False):
        flagmask = sum(map(lambda nf: (nf[1] == &#34;-&#34;) &lt;&lt; (nf[0]+4), self.flags))

        # Only in case we do a dynamic operation, do we include the
        # following calculations
        if flagmask == 0b11110000:
            return [&#34;# No flag operations&#34;]

        lines = []
        # Sets the ones that always get set by operation
        lines.append(&#34;flag = &#34; + format(sum(map(lambda nf: (nf[1] == &#34;1&#34;) &lt;&lt; (nf[0]+4),
                                                self.flags)), &#34;#010b&#34;))

        if self.flag_z == &#34;Z&#34;:
            lines.append(&#34;flag += ((t &amp; 0xFF) == 0) &lt;&lt; FLAGZ&#34;)

        if self.flag_h == &#34;H&#34; and op == &#39;-&#39;:
            c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
            lines.append(&#34;flag += (((%s &amp; 0xF) %s (%s &amp; 0xF)%s) &lt; 0) &lt;&lt; FLAGH&#34;
                         % (r0, op, r1, c))
        elif self.flag_h == &#34;H&#34;:
            c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
            lines.append(&#34;flag += (((%s &amp; 0xF) %s (%s &amp; 0xF)%s) &gt; 0xF) &lt;&lt; FLAGH&#34;
                         % (r0, op, r1, c))

        if self.flag_c == &#34;C&#34; and op == &#39;-&#39;:
            lines.append(&#34;flag += (t &lt; 0) &lt;&lt; FLAGC&#34;)
        elif self.flag_c == &#34;C&#34;:
            lines.append(&#34;flag += (t &gt; 0xFF) &lt;&lt; FLAGC&#34;)

        # Clears all flags affected by the operation
        lines.append(&#34;cpu.F &amp;= &#34; + format(flagmask, &#34;#010b&#34;))
        lines.append(&#34;cpu.F |= flag&#34;)
        return lines

    ###################################################################
    #
    # MISC OPERATIONS
    #
    def NOP(self):
        code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
        return code.getcode()

    def HALT(self):
        code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles,
                    branch_op=True)

        # TODO: Implement HALT bug. If master interrupt is disabled,
        # the intruction following HALT is skipped
        code.addlines([
            &#34;if cpu.interrupt_master_enable:&#34;,
            &#34;\tcpu.halted = True&#34;,
            &#34;else:&#34;,
            &#34;\tcpu.PC += 1&#34;,
            &#34;return &#34; + self.cycles[0]
        ])
        return code.getcode()

    def CB(self):
        code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
        code.addline(&#34;raise Exception(&#39;CB cannot be called!&#39;)&#34;)
        return code.getcode()

    def EI(self):
        code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
        code.addline(&#34;cpu.interrupt_master_enable = True&#34;)
        return code.getcode()

    def DI(self):
        code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
        code.addline(&#34;cpu.interrupt_master_enable = False&#34;)
        return code.getcode()

    def STOP(self):
        code = Code(self.name.split()[0], self.opcode, self.name, True, self.length, self.cycles)
        code.addline(&#34;pass&#34;)
        # code.addLine(&#34;raise Exception(&#39;STOP not implemented!&#39;)&#34;)
        return code.getcode()

    def DAA(self):
        left = Operand(&#39;A&#39;)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)

        # http://stackoverflow.com/a/29990058/3831206
        # http://forums.nesdev.com/viewtopic.php?t=9088
        code.addlines([
            &#34;t = %s&#34; % left.get,

            &#34;corr = 0&#34;,
            &#34;corr |= 0x06 if cpu.f_h() else 0x00&#34;,
            &#34;corr |= 0x60 if cpu.f_c() else 0x00&#34;,

            &#34;if cpu.f_n():&#34;,
            &#34;\tt -= corr&#34;,
            &#34;else:&#34;,
            &#34;\tcorr |= 0x06 if (t &amp; 0x0F) &gt; 0x09 else 0x00&#34;,
            &#34;\tcorr |= 0x60 if t &gt; 0x99 else 0x00&#34;,
            &#34;\tt += corr&#34;,

            &#34;flag = 0&#34;,
            &#34;flag += ((t &amp; 0xFF) == 0) &lt;&lt; FLAGZ&#34;,
            &#34;flag += (corr &amp; 0x60 != 0) &lt;&lt; FLAGC&#34;,
            &#34;cpu.F &amp;= 0b01000000&#34;,
            &#34;cpu.F |= flag&#34;,
            &#34;t &amp;= 0xFF&#34;,

            left.set % &#34;t&#34;
        ])
        return code.getcode()

    def SCF(self):
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addlines(self.handleflags8bit(None, None, None))
        return code.getcode()

    def CCF(self):
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addlines([
            &#34;flag = (cpu.F &amp; 0b00010000) ^ 0b00010000&#34;,
            &#34;cpu.F &amp;= 0b10000000&#34;,
            &#34;cpu.F |= flag&#34;,
        ])
        return code.getcode()

    def CPL(self):
        left = Operand(&#39;A&#39;)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(left.set % (&#34;(~%s) &amp; 0xFF&#34; % left.get))
        code.addlines(self.handleflags8bit(None, None, None))
        return code.getcode()

    ###################################################################
    #
    # LOAD OPERATIONS
    #
    def LD(self):
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)

        # FIX: There seems to be a wrong opcode length on E2 and F2
        if self.opcode == 0xE2 or self.opcode == 0xF2:
            self.length = 1

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        if self.is16bit and left.immediate and left.pointer:
            code.addline(left.set % (&#34;%s &amp; 0xFF&#34; % right.get))
            a, b = left.set.split(&#34;,&#34;)
            code.addline((a + &#34;+1,&#34; + b) % (&#34;%s &gt;&gt; 8&#34; % right.get))
        else:
            # Special handling of AF, BC, DE
            # print(left.set, right.get, hex(self.opcode))
            code.addline(left.set % right.get)

        # Special HL-only operations
        if left.postoperation is not None:
            code.addline(left.postoperation)
        elif right.postoperation is not None:
            code.addline(right.postoperation)
        elif self.opcode == 0xF8:
            # E8 and F8 http://forums.nesdev.com/viewtopic.php?p=42138
            code.addline(&#34;t = cpu.HL&#34;)
            code.addlines(self.handleflags16bit_E8_F8(&#34;cpu.SP&#34;, &#34;v&#34;, &#39;+&#39;, False))
            code.addline(&#34;cpu.HL &amp;= 0xFFFF&#34;)

        return code.getcode()

    def LDH(self):
        return self.LD()

    ###################################################################
    #
    # ALU OPERATIONS
    #
    def ALU(self, left, right, op, carry=False):
        lines = []

        left.assign = False
        right.assign = False
        calc = &#34; &#34;.join([&#34;t&#34;, &#34;=&#34;, left.get, op, right.get])

        if carry:
            calc += &#34; &#34; + op + &#34; cpu.f_c()&#34;

        lines.append(calc)

        if self.opcode == 0xE8:
            # E8 and F8 http://forums.nesdev.com/viewtopic.php?p=42138
            lines.extend(self.handleflags16bit_E8_F8(left.get, &#34;v&#34;, op, carry))
            lines.append(&#34;t &amp;= 0xFFFF&#34;)
        elif self.is16bit:
            lines.extend(self.handleflags16bit(left.get, right.get, op, carry))
            lines.append(&#34;t &amp;= 0xFFFF&#34;)
        else:
            lines.extend(self.handleflags8bit(left.get, right.get, op, carry))
            lines.append(&#34;t &amp;= 0xFF&#34;)

        # HAS TO BE THE LAST INSTRUCTION BECAUSE OF CP!
        lines.append(left.set % &#34;t&#34;)
        return lines

    def ADD(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;+&#39;))
        return code.getcode()

    def SUB(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;-&#39;))
        return code.getcode()

    def INC(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        right = Literal(1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;+&#39;))
        return code.getcode()

    def DEC(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        right = Literal(1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;-&#39;))
        return code.getcode()

    def ADC(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;+&#39;, carry=True))
        return code.getcode()

    def SBC(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;-&#39;, carry=True))
        return code.getcode()

    def AND(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;&amp;&#39;))
        return code.getcode()

    def OR(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;|&#39;))
        return code.getcode()

    def XOR(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;^&#39;))
        return code.getcode()

    def CP(self):
        r1 = self.name.split()[1]
        left = Operand(&#39;A&#39;)
        right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        # CP is equal to SUB, but without saving the result.
        # Therefore; we discard the last instruction.
        code.addlines(self.ALU(left, right, &#39;-&#39;)[:-1])
        return code.getcode()

    ###################################################################
    #
    # PUSH/POP OPERATIONS
    #
    def PUSH(self):
        r0 = self.name.split()[1]
        left = Operand(r0)

        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        if &#34;HL&#34; in left.get:
            code.addlines([
                &#34;cpu.mb.setitem(cpu.SP-1, cpu.HL &gt;&gt; 8) # High&#34;,
                &#34;cpu.mb.setitem(cpu.SP-2, cpu.HL &amp; 0xFF) # Low&#34;,
                &#34;cpu.SP -= 2&#34;])
        else:
            # A bit of a hack, but you can only push double registers
            code.addline(&#34;cpu.mb.setitem(cpu.SP-1, cpu.%s) # High&#34; % left.operand[-2])
            if left.operand == &#34;AF&#34;:
                # by taking fx &#39;A&#39; and &#39;F&#39; directly, we save calculations
                code.addline(&#34;cpu.mb.setitem(cpu.SP-2, cpu.%s &amp; 0xF0) # Low&#34;
                             % left.operand[-1])
            else:
                # by taking fx &#39;A&#39; and &#39;F&#39; directly, we save calculations
                code.addline(&#34;cpu.mb.setitem(cpu.SP-2, cpu.%s) # Low&#34; % left.operand[-1])
            code.addline(&#34;cpu.SP -= 2&#34;)

        return code.getcode()

    def POP(self):
        r0 = self.name.split()[1]
        left = Operand(r0)

        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        if &#34;HL&#34; in left.get:
            code.addlines([(left.set % &#34;(cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8) + &#34;
                            &#34;cpu.mb.getitem(cpu.SP)&#34;) + &#34; # High&#34;,
                           &#34;cpu.SP += 2&#34;])
        else:
            if left.operand.endswith(&#39;F&#39;): # Catching AF
                fmask = &#34; &amp; 0xF0&#34;
            else:
                fmask = &#34;&#34;
            # See comment from PUSH
            code.addline(&#34;cpu.%s = cpu.mb.getitem(cpu.SP+1) # High&#34; % left.operand[-2])
            if left.operand == &#34;AF&#34;:
                code.addline(&#34;cpu.%s = cpu.mb.getitem(cpu.SP)%s &amp; 0xF0 # Low&#34;
                             % (left.operand[-1], fmask))
            else:
                code.addline(&#34;cpu.%s = cpu.mb.getitem(cpu.SP)%s # Low&#34;
                             % (left.operand[-1], fmask))
            code.addline(&#34;cpu.SP += 2&#34;)

        return code.getcode()

    ###################################################################
    #
    # CONTROL FLOW OPERATIONS
    #
    def JP(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = None
            right = Operand(r1)

        r_code = right.get
        if left is not None:
            l_code = left.get
            if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
                left.flag = True
                l_code = &#34;cpu.f_c()&#34;
            assert left.flag
        elif right.pointer:
            # FIX: Wrongful syntax of &#34;JP (HL)&#34; actually meaning &#34;JP HL&#34;
            right.pointer = False
            r_code = right.codegen(False, operand=&#34;HL&#34;)
        else:
            assert right.immediate

        code = Code(self.name.split()[0], self.opcode, self.name, right.immediate, self.length,
                    self.cycles, branch_op=True)
        if left is None:
            code.addlines([
                &#34;cpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else r_code),
                &#34;return &#34; + self.cycles[0]
            ])
        else:
            code.addlines([
                &#34;if %s:&#34; % l_code,
                &#34;\tcpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else r_code),
                &#34;\treturn &#34; + self.cycles[0],
                &#34;else:&#34;,
                &#34;\tcpu.PC += %s&#34; % self.length,
                &#34;\treturn &#34; + self.cycles[1]
            ])

        return code.getcode()

    def JR(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = None
            right = Operand(r1)

        if left is not None:
            l_code = left.get
            if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
                left.flag = True
                l_code = &#34;cpu.f_c()&#34;
            assert left.flag
        assert right.immediate

        code = Code(self.name.split()[0], self.opcode, self.name, right.immediate, self.length,
                    self.cycles, branch_op=True)
        if left is None:
            code.addlines([
                &#34;cpu.PC += %d + &#34; % self.length + inline_signed_int8(&#34;v&#34;),
                &#34;cpu.PC &amp;= 0xFFFF&#34;,
                &#34;return &#34; + self.cycles[0]])
        else:
            code.addlines([
                &#34;cpu.PC += %d&#34; % self.length,
                &#34;if %s:&#34; % l_code,
                &#34;\tcpu.PC += &#34; + inline_signed_int8(&#34;v&#34;),
                &#34;\tcpu.PC &amp;= 0xFFFF&#34;,
                &#34;\treturn &#34; + self.cycles[0],
                &#34;else:&#34;,
                &#34;\tcpu.PC &amp;= 0xFFFF&#34;,
                &#34;\treturn &#34; + self.cycles[1]])

        return code.getcode()

    def CALL(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = None
            right = Operand(r1)

        if left is not None:
            l_code = left.get
            if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
                left.flag = True
                l_code = &#34;cpu.f_c()&#34;
            assert left.flag
        assert right.immediate

        code = Code(self.name.split()[0], self.opcode, self.name, right.immediate, self.length,
                    self.cycles, branch_op=True)

        # Taken from PUSH
        code.addlines([
            &#34;cpu.PC += %s&#34; % self.length,
            &#34;cpu.PC &amp;= 0xFFFF&#34;])

        if left is None:
            code.addlines([
                &#34;cpu.mb.setitem(cpu.SP-1, cpu.PC &gt;&gt; 8) # High&#34;,
                &#34;cpu.mb.setitem(cpu.SP-2, cpu.PC &amp; 0xFF) # Low&#34;,
                &#34;cpu.SP -= 2&#34;,
                &#34;cpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else right.get),
                &#34;return &#34; + self.cycles[0]])
        else:
            code.addlines([
                &#34;if %s:&#34; % l_code,
                &#34;\tcpu.mb.setitem(cpu.SP-1, cpu.PC &gt;&gt; 8) # High&#34;,
                &#34;\tcpu.mb.setitem(cpu.SP-2, cpu.PC &amp; 0xFF) # Low&#34;,
                &#34;\tcpu.SP -= 2&#34;,
                &#34;\tcpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else right.get),
                &#34;\treturn &#34; + self.cycles[0],
                &#34;else:&#34;,
                &#34;\treturn &#34; + self.cycles[1]])

        return code.getcode()

    def RET(self):
        if self.name == &#34;RET&#34;:
            left = None
        else:
            r0 = self.name.split()[1]
            left = Operand(r0)

            l_code = left.get
            if left is not None:
                if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
                    left.flag = True
                    l_code = &#34;cpu.f_c()&#34;
                assert left.flag

        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles,
                    branch_op=True)
        if left is None:
            code.addlines([
                &#34;cpu.PC = cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8 # High&#34;,
                &#34;cpu.PC |= cpu.mb.getitem(cpu.SP) # Low&#34;,
                &#34;cpu.SP += 2&#34;,
                &#34;return &#34; + self.cycles[0]])
        else:
            code.addlines([
                &#34;if %s:&#34; % l_code,
                &#34;\tcpu.PC = cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8 # High&#34;,
                &#34;\tcpu.PC |= cpu.mb.getitem(cpu.SP) # Low&#34;,
                &#34;\tcpu.SP += 2&#34;,
                &#34;\treturn &#34; + self.cycles[0],
                &#34;else:&#34;,
                &#34;\tcpu.PC += %s&#34; % self.length,
                &#34;\tcpu.PC &amp;= 0xFFFF&#34;,
                &#34;\treturn &#34; + self.cycles[1]])

        return code.getcode()

    def RETI(self):
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles,
                    branch_op=True)
        code.addline(&#34;cpu.interrupt_master_enable = True&#34;)
        code.addlines([
            &#34;cpu.PC = cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8 # High&#34;,
            &#34;cpu.PC |= cpu.mb.getitem(cpu.SP) # Low&#34;,
            &#34;cpu.SP += 2&#34;,
            &#34;return &#34; + self.cycles[0]])

        return code.getcode()

    def RST(self):
        r1 = self.name.split()[1]
        right = Literal(r1)

        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles,
                    branch_op=True)

        # Taken from PUSH and CALL
        code.addlines([
            &#34;cpu.PC += %s&#34; % self.length,
            &#34;cpu.mb.setitem(cpu.SP-1, cpu.PC &gt;&gt; 8) # High&#34;,
            &#34;cpu.mb.setitem(cpu.SP-2, cpu.PC &amp; 0xFF) # Low&#34;,
            &#34;cpu.SP -= 2&#34;])

        code.addlines([
            &#34;cpu.PC = %s&#34; % (right.code),
            &#34;return &#34; + self.cycles[0]])

        return code.getcode()

    ###################################################################
    #
    # ROTATE/SHIFT OPERATIONS
    #
    def rotateleft(self, name, left, throughcarry=False):
        code = Code(name, self.opcode, self.name, False, self.length, self.cycles)
        left.assign = False
        if throughcarry:
            code.addline((&#34;t = (%s &lt;&lt; 1)&#34; % left.get) + &#34; + cpu.f_c()&#34;)
        else:
            code.addline(&#34;t = (%s &lt;&lt; 1) + (%s &gt;&gt; 7)&#34; % (left.get, left.get))
        code.addlines(self.handleflags8bit(left.get, None, None, throughcarry))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        left.assign = True
        code.addline(left.set % &#34;t&#34;)
        return code

    def RLA(self):
        left = Operand(&#39;A&#39;)
        code = self.rotateleft(self.name.split()[0], left, throughcarry=True)
        return code.getcode()

    def RLCA(self):
        left = Operand(&#39;A&#39;)
        code = self.rotateleft(self.name.split()[0], left)
        return code.getcode()

    def RLC(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = self.rotateleft(self.name.split()[0], left)
        return code.getcode()

    def RL(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = self.rotateleft(self.name.split()[0], left, throughcarry=True)
        return code.getcode()

    def rotateright(self, name, left, throughcarry=False):
        code = Code(name, self.opcode, self.name, False, self.length, self.cycles)
        left.assign = False
        if throughcarry:
            # Trigger &#34;overflow&#34; for carry flag
            code.addline((&#34;t = (%s &gt;&gt; 1)&#34; % left.get) +
                         &#34; + (cpu.f_c() &lt;&lt; 7)&#34; + &#34; + ((%s &amp; 1) &lt;&lt; 8)&#34; % (left.get))
        else:
            # Trigger &#34;overflow&#34; for carry flag
            code.addline(&#34;t = (%s &gt;&gt; 1) + ((%s &amp; 1) &lt;&lt; 7)&#34; % (left.get, left.get)
                         + &#34; + ((%s &amp; 1) &lt;&lt; 8)&#34; % (left.get))
        code.addlines(self.handleflags8bit(left.get, None, None, throughcarry))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        code.addline(left.set % &#34;t&#34;)
        return code

    def RRA(self):
        left = Operand(&#39;A&#39;)
        code = self.rotateright(self.name.split()[0], left, throughcarry=True)
        return code.getcode()

    def RRCA(self):
        left = Operand(&#39;A&#39;)
        code = self.rotateright(self.name.split()[0], left)
        return code.getcode()

    def RRC(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = self.rotateright(self.name.split()[0], left)
        return code.getcode()

    def RR(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = self.rotateright(self.name.split()[0], left, throughcarry=True)
        return code.getcode()

    def SLA(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(&#34;t = (%s &lt;&lt; 1)&#34; % left.get)
        code.addlines(self.handleflags8bit(left.get, None, None, False))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        code.addline(left.set % &#34;t&#34;)
        return code.getcode()

    def SRA(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        # FIX: All documentation tells it should have carry enabled
        self.flag_c = &#39;C&#39;
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        # Actual shift / MSB unchanged / Trigger &#34;overflow&#34; for carry flag
        code.addline(&#34;t = ((%s &gt;&gt; 1) | (%s &amp; 0x80)) + ((%s &amp; 1) &lt;&lt; 8)&#34;
                     % (left.get, left.get, left.get))
        code.addlines(self.handleflags8bit(left.get, None, None, False))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        code.addline(left.set % &#34;t&#34;)
        return code.getcode()

    def SRL(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        #              Actual shift / Trigger &#34;overflow&#34; for carry flag
        code.addline(&#34;t = (%s &gt;&gt; 1) + ((%s &amp; 1) &lt;&lt; 8)&#34; % (left.get, left.get))
        code.addlines(self.handleflags8bit(left.get, None, None, False))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        code.addline(left.set % &#34;t&#34;)
        return code.getcode()

    def SWAP(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(&#34;t = ((%s &amp; 0xF0) &gt;&gt; 4) | ((%s &amp; 0x0F) &lt;&lt; 4)&#34; % (left.get, left.get))
        code.addlines(self.handleflags8bit(left.get, None, None, False))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        code.addline(left.set % &#34;t&#34;)
        return code.getcode()

    ###################################################################
    #
    # BIT OPERATIONS
    #
    def BIT(self):
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Literal(r0)
        right = Operand(r1)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(&#34;t = %s &amp; (1 &lt;&lt; %s)&#34; % (right.get, left.get))
        code.addlines(self.handleflags8bit(left.get, right.get, None, False))

        return code.getcode()

    def RES(self):
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Literal(r0)
        right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(&#34;t = %s &amp; ~(1 &lt;&lt; %s)&#34; % (right.get, left.get))
        code.addline(right.set % &#34;t&#34;)
        return code.getcode()

    def SET(self):
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Literal(r0)
        right = Operand(r1)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(&#34;t = %s | (1 &lt;&lt; %s)&#34; % (right.get, left.get))
        code.addline(right.set % &#34;t&#34;)
        return code.getcode()


def update():
    response = urlopen(&#34;http://pastraiser.com/cpu/gameboy/gameboy_opcodes.html&#34;)
    html = response.read().replace(b&#39;&amp;nbsp;&#39;, b&#39;&lt;br&gt;&#39;).decode()

    parser = MyHTMLParser()
    parser.feed(html)

    opcodefunctions = map(lambda x: (None, None) if x is None else x.createfunction(), opcodes)

    with open(destination, &#34;w&#34;) as f, open(pxd_destination, &#34;w&#34;) as f_pxd:
        f.write(warning)
        f.write(imports)
        f_pxd.write(warning)
        f_pxd.write(cimports)
        lookuplist = []
        for lookuptuple, code in opcodefunctions:
            lookuplist.append(lookuptuple)

            if code is None:
                continue

            (pxd, functiontext) = code

            # breakpoint()
            f_pxd.write(pxd + &#34;\n&#34;)
            f.write(functiontext.replace(&#39;\t&#39;, &#39; &#39;*4) + &#34;\n\n\n&#34;)

        f.write(&#34;def no_opcode(cpu):\n    return 0\n\n\n&#34;)

        f.write(&#34;def opcode_length(opcode):\n    return OPCODE_LENGTHS[opcode]\n\n&#34;)
        f.write(&#34;&#34;&#34;
def execute_opcode(cpu, opcode):
    oplen = opcode_length(opcode)
    v = 0
    pc = cpu.PC
    if oplen == 2:
        # 8-bit immediate
        v = cpu.mb.getitem(pc+1)
    elif oplen == 3:
        # 16-bit immediate
        # Flips order of values due to big-endian
        a = cpu.mb.getitem(pc+2)
        b = cpu.mb.getitem(pc+1)
        v = (a &lt;&lt; 8) + b

&#34;&#34;&#34;)

        indent = 4
        for i, t in enumerate(lookuplist):
            t = t if t is not None else (0, &#34;no_opcode&#34;, &#34;&#34;)
            f.write(&#34; &#34;*indent + (&#34;if&#34; if i == 0 else &#34;elif&#34;) + &#34; opcode == 0x%0.2X:\n&#34; % i
                    + &#34; &#34;*(indent+4) + &#34;return &#34; + str(t[1]).replace(&#34;&#39;&#34;, &#34;&#34;)
                    + (&#34;(cpu)&#34; if t[0] &lt;= 1 else &#39;(cpu, v)&#39;) + &#34;\n&#34;)
        f.write(&#39;\n\n&#39;)

        f.write(&#39;OPCODE_LENGTHS = array.array(&#34;B&#34;, [\n    &#39;)
        for i, t in enumerate(lookuplist):
            t = t if t is not None else (0, &#34;no_opcode&#34;, &#34;&#34;)
            f.write(str(t[0]).replace(&#34;&#39;&#34;, &#34;&#34;) + &#34;,&#34;)
            if (i+1) % 16 == 0:
                f.write(&#34;\n&#34; + &#34; &#34;*4)
            else:
                f.write(&#34; &#34;)

        f.write(&#39;])\n&#39;)

        f.write(&#39;\n\n&#39;)
        f.write(&#39;CPU_COMMANDS = [\n    &#39;)
        for _, t in enumerate(lookuplist):
            t = t if t is not None else (0, &#34;no_opcode&#34;, &#34;&#34;)
            f.write(f&#34;\&#34;{t[2]}\&#34;,\n&#34; + &#34; &#34;*4)

        f.write(&#39;]\n&#39;)


def load():
    # if os.path.exists(destination):
    #     return
    update()


if __name__ == &#34;__main__&#34;:
    load()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyboy.core.opcodes_gen.inline_signed_int8"><code class="name flex">
<span>def <span class="ident">inline_signed_int8</span></span>(<span>arg)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def inline_signed_int8(arg):
    return &#34;(({} ^ 0x80) - 0x80)&#34;.format(arg)</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load():
    # if os.path.exists(destination):
    #     return
    update()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update():
    response = urlopen(&#34;http://pastraiser.com/cpu/gameboy/gameboy_opcodes.html&#34;)
    html = response.read().replace(b&#39;&amp;nbsp;&#39;, b&#39;&lt;br&gt;&#39;).decode()

    parser = MyHTMLParser()
    parser.feed(html)

    opcodefunctions = map(lambda x: (None, None) if x is None else x.createfunction(), opcodes)

    with open(destination, &#34;w&#34;) as f, open(pxd_destination, &#34;w&#34;) as f_pxd:
        f.write(warning)
        f.write(imports)
        f_pxd.write(warning)
        f_pxd.write(cimports)
        lookuplist = []
        for lookuptuple, code in opcodefunctions:
            lookuplist.append(lookuptuple)

            if code is None:
                continue

            (pxd, functiontext) = code

            # breakpoint()
            f_pxd.write(pxd + &#34;\n&#34;)
            f.write(functiontext.replace(&#39;\t&#39;, &#39; &#39;*4) + &#34;\n\n\n&#34;)

        f.write(&#34;def no_opcode(cpu):\n    return 0\n\n\n&#34;)

        f.write(&#34;def opcode_length(opcode):\n    return OPCODE_LENGTHS[opcode]\n\n&#34;)
        f.write(&#34;&#34;&#34;
def execute_opcode(cpu, opcode):
    oplen = opcode_length(opcode)
    v = 0
    pc = cpu.PC
    if oplen == 2:
        # 8-bit immediate
        v = cpu.mb.getitem(pc+1)
    elif oplen == 3:
        # 16-bit immediate
        # Flips order of values due to big-endian
        a = cpu.mb.getitem(pc+2)
        b = cpu.mb.getitem(pc+1)
        v = (a &lt;&lt; 8) + b

&#34;&#34;&#34;)

        indent = 4
        for i, t in enumerate(lookuplist):
            t = t if t is not None else (0, &#34;no_opcode&#34;, &#34;&#34;)
            f.write(&#34; &#34;*indent + (&#34;if&#34; if i == 0 else &#34;elif&#34;) + &#34; opcode == 0x%0.2X:\n&#34; % i
                    + &#34; &#34;*(indent+4) + &#34;return &#34; + str(t[1]).replace(&#34;&#39;&#34;, &#34;&#34;)
                    + (&#34;(cpu)&#34; if t[0] &lt;= 1 else &#39;(cpu, v)&#39;) + &#34;\n&#34;)
        f.write(&#39;\n\n&#39;)

        f.write(&#39;OPCODE_LENGTHS = array.array(&#34;B&#34;, [\n    &#39;)
        for i, t in enumerate(lookuplist):
            t = t if t is not None else (0, &#34;no_opcode&#34;, &#34;&#34;)
            f.write(str(t[0]).replace(&#34;&#39;&#34;, &#34;&#34;) + &#34;,&#34;)
            if (i+1) % 16 == 0:
                f.write(&#34;\n&#34; + &#34; &#34;*4)
            else:
                f.write(&#34; &#34;)

        f.write(&#39;])\n&#39;)

        f.write(&#39;\n\n&#39;)
        f.write(&#39;CPU_COMMANDS = [\n    &#39;)
        for _, t in enumerate(lookuplist):
            t = t if t is not None else (0, &#34;no_opcode&#34;, &#34;&#34;)
            f.write(f&#34;\&#34;{t[2]}\&#34;,\n&#34; + &#34; &#34;*4)

        f.write(&#39;]\n&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyboy.core.opcodes_gen.Code"><code class="flex name class">
<span>class <span class="ident">Code</span></span>
<span>(</span><span>function_name, opcode, name, takes_immediate, length, cycles, branch_op=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Code:
    def __init__(self, function_name, opcode, name, takes_immediate, length, cycles,
                 branch_op=False):
        self.function_name = function_name
        self.opcode = opcode
        self.name = name
        self.cycles = cycles
        self.takes_immediate = takes_immediate
        self.length = length
        self.lines = []
        self.branch_op = branch_op

    def addline(self, line):
        self.lines.append(line)

    def addlines(self, lines):
        for l in lines:
            self.lines.append(l)

    def getcode(self):
        code = &#34;&#34;
        code += [&#34;def %s_%0.2X(cpu): # %0.2X %s&#34;
                 % (self.function_name, self.opcode, self.opcode, self.name),
                 &#34;def %s_%0.2X(cpu, v): # %0.2X %s&#34;
                 % (self.function_name, self.opcode, self.opcode, self.name)][self.takes_immediate]
        code += &#34;\n\t&#34;

        if not self.branch_op:
            self.lines.append(&#34;cpu.PC += %d&#34; % self.length)
            self.lines.append(&#34;return &#34; + self.cycles[0]) # Choose the 0th cycle count

        code += &#34;\n\t&#34;.join(self.lines)

        pxd = [&#34;cdef uint8_t %s_%0.2X(cpu.CPU) except -1 # %0.2X %s&#34;
               % (self.function_name, self.opcode, self.opcode, self.name),
               # TODO: Differentiate between 16-bit values
               # (01,11,21,31 ops) and 8-bit values for &#39;v&#39;
               &#34;cdef uint8_t %s_%0.2X(cpu.CPU, int v) except -1 # %0.2X %s&#34;
               % (self.function_name, self.opcode, self.opcode, self.name)][self.takes_immediate]

        if self.opcode == 0x27:
            pxd = &#34;@cython.locals(v=int, flag=uint8_t, t=int, corr=ushort)\n&#34; + pxd
        else:
            pxd = &#34;@cython.locals(v=int, flag=uint8_t, t=int)\n&#34; + pxd

        return (pxd, code)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyboy.core.opcodes_gen.Code.addline"><code class="name flex">
<span>def <span class="ident">addline</span></span>(<span>self, line)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def addline(self, line):
    self.lines.append(line)</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.Code.addlines"><code class="name flex">
<span>def <span class="ident">addlines</span></span>(<span>self, lines)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def addlines(self, lines):
    for l in lines:
        self.lines.append(l)</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.Code.getcode"><code class="name flex">
<span>def <span class="ident">getcode</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getcode(self):
    code = &#34;&#34;
    code += [&#34;def %s_%0.2X(cpu): # %0.2X %s&#34;
             % (self.function_name, self.opcode, self.opcode, self.name),
             &#34;def %s_%0.2X(cpu, v): # %0.2X %s&#34;
             % (self.function_name, self.opcode, self.opcode, self.name)][self.takes_immediate]
    code += &#34;\n\t&#34;

    if not self.branch_op:
        self.lines.append(&#34;cpu.PC += %d&#34; % self.length)
        self.lines.append(&#34;return &#34; + self.cycles[0]) # Choose the 0th cycle count

    code += &#34;\n\t&#34;.join(self.lines)

    pxd = [&#34;cdef uint8_t %s_%0.2X(cpu.CPU) except -1 # %0.2X %s&#34;
           % (self.function_name, self.opcode, self.opcode, self.name),
           # TODO: Differentiate between 16-bit values
           # (01,11,21,31 ops) and 8-bit values for &#39;v&#39;
           &#34;cdef uint8_t %s_%0.2X(cpu.CPU, int v) except -1 # %0.2X %s&#34;
           % (self.function_name, self.opcode, self.opcode, self.name)][self.takes_immediate]

    if self.opcode == 0x27:
        pxd = &#34;@cython.locals(v=int, flag=uint8_t, t=int, corr=ushort)\n&#34; + pxd
    else:
        pxd = &#34;@cython.locals(v=int, flag=uint8_t, t=int)\n&#34; + pxd

    return (pxd, code)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.core.opcodes_gen.Literal"><code class="flex name class">
<span>class <span class="ident">Literal</span></span>
<span>(</span><span>value)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Literal:
    def __init__(self, value):
        if isinstance(value, str) and value.find(&#39;H&#39;) &gt; 0:
            self.value = int(value[:-1], 16)
        else:
            self.value = value
        self.code = str(self.value)
        self.immediate = False

    @property
    def get(self):
        return self.code</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyboy.core.opcodes_gen.Literal.get"><code class="name">var <span class="ident">get</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def get(self):
    return self.code</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.core.opcodes_gen.MyHTMLParser"><code class="flex name class">
<span>class <span class="ident">MyHTMLParser</span></span>
</code></dt>
<dd>
<section class="desc"><p>Find tags and other markup and call handler functions.</p>
<h2 id="usage">Usage</h2>
<p>p = HTMLParser()
p.feed(data)
&hellip;
p.close()
Start tags are handled by calling self.handle_starttag() or
self.handle_startendtag(); end tags by self.handle_endtag().
The
data between tags is passed from the parser to the derived class
by calling self.handle_data() with the data as argument (the data
may be split up in arbitrary chunks).
If convert_charrefs is
True the character references are converted automatically to the
corresponding Unicode character (and self.handle_data() is no
longer split in chunks), otherwise they are passed by calling
self.handle_entityref() or self.handle_charref() with the string
containing respectively the named or numeric reference as the
argument.</p>
<p>Initialize and reset this instance.</p>
<p>If convert_charrefs is True (the default), all character references
are automatically converted to the corresponding Unicode characters.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class MyHTMLParser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)

        self.counter = 0
        self.tagstack = []

        self.cell_lines = []
        self.stop = False
        self._attrs = None
        self.founddata = False

    def handle_starttag(self, tag, attrs):
        if tag != &#34;br&#34;:
            self.founddata = False
            self._attrs = attrs
            self.tagstack.append(tag)

    def handle_endtag(self, tag):
        if not self.founddata and self.tagstack[-1] == &#34;td&#34; and self.counter % 0x100 != 0:
            self.counter += 1
            opcodes.append(None) # Blank operations
        self.tagstack.pop()

    def handle_data(self, data):
        if self.stop or len(self.tagstack) == 0:
            return

        self.founddata = True

        if self.tagstack[-1] == &#34;td&#34;:
            self.cell_lines.append(data)

            if len(self.cell_lines) == 4:
                opcodes.append(self.make_opcode(
                    self.cell_lines,
                    (&#34;bgcolor&#34;, &#34;#ccffcc&#34;) in self._attrs or
                    (&#34;bgcolor&#34;, &#34;#ffcccc&#34;) in self._attrs))
                self.counter += 1
                self.cell_lines = []

        if self.counter == 0x200:
            self.stop = True

    def make_opcode(self, lines, bit16):
        opcode = self.counter
        flags = lines.pop()
        cycles = lines.pop()
        length = lines.pop()
        name = lines.pop()

        return OpcodeData(opcode, name, length, cycles, bit16, *flags.split())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>html.parser.HTMLParser</li>
<li>_markupbase.ParserBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyboy.core.opcodes_gen.MyHTMLParser.handle_data"><code class="name flex">
<span>def <span class="ident">handle_data</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_data(self, data):
    if self.stop or len(self.tagstack) == 0:
        return

    self.founddata = True

    if self.tagstack[-1] == &#34;td&#34;:
        self.cell_lines.append(data)

        if len(self.cell_lines) == 4:
            opcodes.append(self.make_opcode(
                self.cell_lines,
                (&#34;bgcolor&#34;, &#34;#ccffcc&#34;) in self._attrs or
                (&#34;bgcolor&#34;, &#34;#ffcccc&#34;) in self._attrs))
            self.counter += 1
            self.cell_lines = []

    if self.counter == 0x200:
        self.stop = True</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.MyHTMLParser.handle_endtag"><code class="name flex">
<span>def <span class="ident">handle_endtag</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_endtag(self, tag):
    if not self.founddata and self.tagstack[-1] == &#34;td&#34; and self.counter % 0x100 != 0:
        self.counter += 1
        opcodes.append(None) # Blank operations
    self.tagstack.pop()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.MyHTMLParser.handle_starttag"><code class="name flex">
<span>def <span class="ident">handle_starttag</span></span>(<span>self, tag, attrs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_starttag(self, tag, attrs):
    if tag != &#34;br&#34;:
        self.founddata = False
        self._attrs = attrs
        self.tagstack.append(tag)</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.MyHTMLParser.make_opcode"><code class="name flex">
<span>def <span class="ident">make_opcode</span></span>(<span>self, lines, bit16)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_opcode(self, lines, bit16):
    opcode = self.counter
    flags = lines.pop()
    cycles = lines.pop()
    length = lines.pop()
    name = lines.pop()

    return OpcodeData(opcode, name, length, cycles, bit16, *flags.split())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData"><code class="flex name class">
<span>class <span class="ident">OpcodeData</span></span>
<span>(</span><span>opcode, name, length, cycles, bit16, flag_z, flag_n, flag_h, flag_c)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class OpcodeData:
    def __init__(self, opcode, name, length, cycles, bit16, flag_z, flag_n, flag_h, flag_c):
        self.opcode = opcode
        self.name = name
        self.length = int(length)
        self.cycles = tuple(cycles.split(&#34;/&#34;))
        self.flag_z = flag_z
        self.flag_n = flag_n
        self.flag_h = flag_h
        self.flag_c = flag_c
        self.flags = tuple(enumerate([self.flag_c, self.flag_h, self.flag_n, self.flag_z]))
        self.is16bit = bit16

        # TODO: There&#39;s no need for this to be so explicit
        self.functionhandlers = {
            &#34;NOP&#34;    : self.NOP,
            &#34;HALT&#34;   : self.HALT,
            &#34;PREFIX&#34; : self.CB,
            &#34;EI&#34;     : self.EI,
            &#34;DI&#34;     : self.DI,
            &#34;STOP&#34;   : self.STOP,

            &#34;LD&#34;     : self.LD,
            &#34;LDH&#34;    : self.LDH,

            &#34;ADD&#34;    : self.ADD,
            &#34;SUB&#34;    : self.SUB,
            &#34;INC&#34;    : self.INC,
            &#34;DEC&#34;    : self.DEC,
            &#34;ADC&#34;    : self.ADC,
            &#34;SBC&#34;    : self.SBC,

            &#34;AND&#34;    : self.AND,
            &#34;OR&#34;     : self.OR,
            &#34;XOR&#34;    : self.XOR,
            &#34;CP&#34;     : self.CP,

            &#34;PUSH&#34;   : self.PUSH,
            &#34;POP&#34;    : self.POP,

            &#34;JP&#34;     : self.JP,
            &#34;JR&#34;     : self.JR,
            &#34;CALL&#34;   : self.CALL,
            &#34;RET&#34;    : self.RET,
            &#34;RETI&#34;   : self.RETI,
            &#34;RST&#34;    : self.RST,

            &#34;DAA&#34;    : self.DAA,
            &#34;SCF&#34;    : self.SCF,
            &#34;CCF&#34;    : self.CCF,
            &#34;CPL&#34;    : self.CPL,

            &#34;RLA&#34;    : self.RLA,
            &#34;RLCA&#34;   : self.RLCA,
            &#34;RLC&#34;    : self.RLC,
            &#34;RL&#34;     : self.RL,
            &#34;RRA&#34;    : self.RRA,
            &#34;RRCA&#34;   : self.RRCA,
            &#34;RRC&#34;    : self.RRC,
            &#34;RR&#34;     : self.RR,

            &#34;SLA&#34;    : self.SLA,
            &#34;SRA&#34;    : self.SRA,
            &#34;SWAP&#34;   : self.SWAP,
            &#34;SRL&#34;    : self.SRL,
            &#34;BIT&#34;    : self.BIT,
            &#34;RES&#34;    : self.RES,
            &#34;SET&#34;    : self.SET
        }

    def createfunction(self):
        text = self.functionhandlers[self.name.split()[0]]()
        # Compensate for CB operations being &#34;2 bytes long&#34;
        if self.opcode &gt; 0xFF:
            self.length -= 1
        return (self.length, &#34;%s_%0.2X&#34; % (self.name.split()[0], self.opcode), self.name), text

    # Special carry and half-carry for E8 and F8:
    # http://forums.nesdev.com/viewtopic.php?p=42138
    # Blargg: &#34;Both of these set carry and half-carry based on the low
    # byte of SP added to the UNSIGNED immediate byte. The Negative
    # and Zero flags are always cleared. They also calculate SP +
    # SIGNED immediate byte and put the result into SP or HL,
    # respectively.&#34;
    def handleflags16bit_E8_F8(self, r0, r1, op, carry=False):
        flagmask = sum(map(lambda nf: (nf[1] == &#34;-&#34;) &lt;&lt; (nf[0]+4), self.flags))

        # Only in case we do a dynamic operation, do we include the
        # following calculations
        if flagmask == 0b11110000:
            return [&#34;# No flag operations&#34;]

        lines = []
        # Sets the flags that always get set by operation
        lines.append(&#34;flag = &#34; + format(sum(map(lambda nf: (nf[1] == &#34;1&#34;) &lt;&lt; (nf[0]+4),
                                                self.flags)), &#34;#010b&#34;))

        # flag += (((cpu.SP &amp; 0xF) + (v &amp; 0xF)) &gt; 0xF) &lt;&lt; FLAGH
        if self.flag_h == &#34;H&#34;:
            c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
            lines.append(&#34;flag += (((%s &amp; 0xF) %s (%s &amp; 0xF)%s) &gt; 0xF) &lt;&lt; FLAGH&#34;
                         % (r0, op, r1, c))

        # flag += (((cpu.SP &amp; 0xFF) + (v &amp; 0xFF)) &gt; 0xFF) &lt;&lt; FLAGC
        if self.flag_c == &#34;C&#34;:
            lines.append(&#34;flag += (((%s &amp; 0xFF) %s (%s &amp; 0xFF)%s) &gt; 0xFF) &lt;&lt; FLAGC&#34;
                         % (r0, op, r1, c))

        # Clears all flags affected by the operation
        lines.append(&#34;cpu.F &amp;= &#34; + format(flagmask, &#34;#010b&#34;))
        lines.append(&#34;cpu.F |= flag&#34;)
        return lines

    def handleflags16bit(self, r0, r1, op, carry=False):
        flagmask = sum(map(lambda nf: (nf[1] == &#34;-&#34;) &lt;&lt; (nf[0]+4), self.flags))

        # Only in case we do a dynamic operation, do we include the
        # following calculations
        if flagmask == 0b11110000:
            return [&#34;# No flag operations&#34;]

        lines = []
        # Sets the ones that always get set by operation
        lines.append(&#34;flag = &#34; + format(sum(map(lambda nf: (nf[1] == &#34;1&#34;) &lt;&lt; (nf[0]+4),
                                                self.flags)), &#34;#010b&#34;))

        if self.flag_h == &#34;H&#34;:
            c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
            lines.append(&#34;flag += (((%s &amp; 0xFFF) %s (%s &amp; 0xFFF)%s) &gt; 0xFFF) &lt;&lt; FLAGH&#34;
                         % (r0, op, r1, c))

        if self.flag_c == &#34;C&#34;:
            lines.append(&#34;flag += (t &gt; 0xFFFF) &lt;&lt; FLAGC&#34;)

        # Clears all flags affected by the operation
        lines.append(&#34;cpu.F &amp;= &#34; + format(flagmask, &#34;#010b&#34;))
        lines.append(&#34;cpu.F |= flag&#34;)
        return lines

    def handleflags8bit(self, r0, r1, op, carry=False):
        flagmask = sum(map(lambda nf: (nf[1] == &#34;-&#34;) &lt;&lt; (nf[0]+4), self.flags))

        # Only in case we do a dynamic operation, do we include the
        # following calculations
        if flagmask == 0b11110000:
            return [&#34;# No flag operations&#34;]

        lines = []
        # Sets the ones that always get set by operation
        lines.append(&#34;flag = &#34; + format(sum(map(lambda nf: (nf[1] == &#34;1&#34;) &lt;&lt; (nf[0]+4),
                                                self.flags)), &#34;#010b&#34;))

        if self.flag_z == &#34;Z&#34;:
            lines.append(&#34;flag += ((t &amp; 0xFF) == 0) &lt;&lt; FLAGZ&#34;)

        if self.flag_h == &#34;H&#34; and op == &#39;-&#39;:
            c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
            lines.append(&#34;flag += (((%s &amp; 0xF) %s (%s &amp; 0xF)%s) &lt; 0) &lt;&lt; FLAGH&#34;
                         % (r0, op, r1, c))
        elif self.flag_h == &#34;H&#34;:
            c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
            lines.append(&#34;flag += (((%s &amp; 0xF) %s (%s &amp; 0xF)%s) &gt; 0xF) &lt;&lt; FLAGH&#34;
                         % (r0, op, r1, c))

        if self.flag_c == &#34;C&#34; and op == &#39;-&#39;:
            lines.append(&#34;flag += (t &lt; 0) &lt;&lt; FLAGC&#34;)
        elif self.flag_c == &#34;C&#34;:
            lines.append(&#34;flag += (t &gt; 0xFF) &lt;&lt; FLAGC&#34;)

        # Clears all flags affected by the operation
        lines.append(&#34;cpu.F &amp;= &#34; + format(flagmask, &#34;#010b&#34;))
        lines.append(&#34;cpu.F |= flag&#34;)
        return lines

    ###################################################################
    #
    # MISC OPERATIONS
    #
    def NOP(self):
        code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
        return code.getcode()

    def HALT(self):
        code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles,
                    branch_op=True)

        # TODO: Implement HALT bug. If master interrupt is disabled,
        # the intruction following HALT is skipped
        code.addlines([
            &#34;if cpu.interrupt_master_enable:&#34;,
            &#34;\tcpu.halted = True&#34;,
            &#34;else:&#34;,
            &#34;\tcpu.PC += 1&#34;,
            &#34;return &#34; + self.cycles[0]
        ])
        return code.getcode()

    def CB(self):
        code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
        code.addline(&#34;raise Exception(&#39;CB cannot be called!&#39;)&#34;)
        return code.getcode()

    def EI(self):
        code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
        code.addline(&#34;cpu.interrupt_master_enable = True&#34;)
        return code.getcode()

    def DI(self):
        code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
        code.addline(&#34;cpu.interrupt_master_enable = False&#34;)
        return code.getcode()

    def STOP(self):
        code = Code(self.name.split()[0], self.opcode, self.name, True, self.length, self.cycles)
        code.addline(&#34;pass&#34;)
        # code.addLine(&#34;raise Exception(&#39;STOP not implemented!&#39;)&#34;)
        return code.getcode()

    def DAA(self):
        left = Operand(&#39;A&#39;)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)

        # http://stackoverflow.com/a/29990058/3831206
        # http://forums.nesdev.com/viewtopic.php?t=9088
        code.addlines([
            &#34;t = %s&#34; % left.get,

            &#34;corr = 0&#34;,
            &#34;corr |= 0x06 if cpu.f_h() else 0x00&#34;,
            &#34;corr |= 0x60 if cpu.f_c() else 0x00&#34;,

            &#34;if cpu.f_n():&#34;,
            &#34;\tt -= corr&#34;,
            &#34;else:&#34;,
            &#34;\tcorr |= 0x06 if (t &amp; 0x0F) &gt; 0x09 else 0x00&#34;,
            &#34;\tcorr |= 0x60 if t &gt; 0x99 else 0x00&#34;,
            &#34;\tt += corr&#34;,

            &#34;flag = 0&#34;,
            &#34;flag += ((t &amp; 0xFF) == 0) &lt;&lt; FLAGZ&#34;,
            &#34;flag += (corr &amp; 0x60 != 0) &lt;&lt; FLAGC&#34;,
            &#34;cpu.F &amp;= 0b01000000&#34;,
            &#34;cpu.F |= flag&#34;,
            &#34;t &amp;= 0xFF&#34;,

            left.set % &#34;t&#34;
        ])
        return code.getcode()

    def SCF(self):
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addlines(self.handleflags8bit(None, None, None))
        return code.getcode()

    def CCF(self):
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addlines([
            &#34;flag = (cpu.F &amp; 0b00010000) ^ 0b00010000&#34;,
            &#34;cpu.F &amp;= 0b10000000&#34;,
            &#34;cpu.F |= flag&#34;,
        ])
        return code.getcode()

    def CPL(self):
        left = Operand(&#39;A&#39;)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(left.set % (&#34;(~%s) &amp; 0xFF&#34; % left.get))
        code.addlines(self.handleflags8bit(None, None, None))
        return code.getcode()

    ###################################################################
    #
    # LOAD OPERATIONS
    #
    def LD(self):
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)

        # FIX: There seems to be a wrong opcode length on E2 and F2
        if self.opcode == 0xE2 or self.opcode == 0xF2:
            self.length = 1

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        if self.is16bit and left.immediate and left.pointer:
            code.addline(left.set % (&#34;%s &amp; 0xFF&#34; % right.get))
            a, b = left.set.split(&#34;,&#34;)
            code.addline((a + &#34;+1,&#34; + b) % (&#34;%s &gt;&gt; 8&#34; % right.get))
        else:
            # Special handling of AF, BC, DE
            # print(left.set, right.get, hex(self.opcode))
            code.addline(left.set % right.get)

        # Special HL-only operations
        if left.postoperation is not None:
            code.addline(left.postoperation)
        elif right.postoperation is not None:
            code.addline(right.postoperation)
        elif self.opcode == 0xF8:
            # E8 and F8 http://forums.nesdev.com/viewtopic.php?p=42138
            code.addline(&#34;t = cpu.HL&#34;)
            code.addlines(self.handleflags16bit_E8_F8(&#34;cpu.SP&#34;, &#34;v&#34;, &#39;+&#39;, False))
            code.addline(&#34;cpu.HL &amp;= 0xFFFF&#34;)

        return code.getcode()

    def LDH(self):
        return self.LD()

    ###################################################################
    #
    # ALU OPERATIONS
    #
    def ALU(self, left, right, op, carry=False):
        lines = []

        left.assign = False
        right.assign = False
        calc = &#34; &#34;.join([&#34;t&#34;, &#34;=&#34;, left.get, op, right.get])

        if carry:
            calc += &#34; &#34; + op + &#34; cpu.f_c()&#34;

        lines.append(calc)

        if self.opcode == 0xE8:
            # E8 and F8 http://forums.nesdev.com/viewtopic.php?p=42138
            lines.extend(self.handleflags16bit_E8_F8(left.get, &#34;v&#34;, op, carry))
            lines.append(&#34;t &amp;= 0xFFFF&#34;)
        elif self.is16bit:
            lines.extend(self.handleflags16bit(left.get, right.get, op, carry))
            lines.append(&#34;t &amp;= 0xFFFF&#34;)
        else:
            lines.extend(self.handleflags8bit(left.get, right.get, op, carry))
            lines.append(&#34;t &amp;= 0xFF&#34;)

        # HAS TO BE THE LAST INSTRUCTION BECAUSE OF CP!
        lines.append(left.set % &#34;t&#34;)
        return lines

    def ADD(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;+&#39;))
        return code.getcode()

    def SUB(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;-&#39;))
        return code.getcode()

    def INC(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        right = Literal(1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;+&#39;))
        return code.getcode()

    def DEC(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        right = Literal(1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;-&#39;))
        return code.getcode()

    def ADC(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;+&#39;, carry=True))
        return code.getcode()

    def SBC(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;-&#39;, carry=True))
        return code.getcode()

    def AND(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;&amp;&#39;))
        return code.getcode()

    def OR(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;|&#39;))
        return code.getcode()

    def XOR(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = Operand(&#39;A&#39;)
            right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        code.addlines(self.ALU(left, right, &#39;^&#39;))
        return code.getcode()

    def CP(self):
        r1 = self.name.split()[1]
        left = Operand(&#39;A&#39;)
        right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name,
                    left.immediate or right.immediate, self.length, self.cycles)
        # CP is equal to SUB, but without saving the result.
        # Therefore; we discard the last instruction.
        code.addlines(self.ALU(left, right, &#39;-&#39;)[:-1])
        return code.getcode()

    ###################################################################
    #
    # PUSH/POP OPERATIONS
    #
    def PUSH(self):
        r0 = self.name.split()[1]
        left = Operand(r0)

        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        if &#34;HL&#34; in left.get:
            code.addlines([
                &#34;cpu.mb.setitem(cpu.SP-1, cpu.HL &gt;&gt; 8) # High&#34;,
                &#34;cpu.mb.setitem(cpu.SP-2, cpu.HL &amp; 0xFF) # Low&#34;,
                &#34;cpu.SP -= 2&#34;])
        else:
            # A bit of a hack, but you can only push double registers
            code.addline(&#34;cpu.mb.setitem(cpu.SP-1, cpu.%s) # High&#34; % left.operand[-2])
            if left.operand == &#34;AF&#34;:
                # by taking fx &#39;A&#39; and &#39;F&#39; directly, we save calculations
                code.addline(&#34;cpu.mb.setitem(cpu.SP-2, cpu.%s &amp; 0xF0) # Low&#34;
                             % left.operand[-1])
            else:
                # by taking fx &#39;A&#39; and &#39;F&#39; directly, we save calculations
                code.addline(&#34;cpu.mb.setitem(cpu.SP-2, cpu.%s) # Low&#34; % left.operand[-1])
            code.addline(&#34;cpu.SP -= 2&#34;)

        return code.getcode()

    def POP(self):
        r0 = self.name.split()[1]
        left = Operand(r0)

        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        if &#34;HL&#34; in left.get:
            code.addlines([(left.set % &#34;(cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8) + &#34;
                            &#34;cpu.mb.getitem(cpu.SP)&#34;) + &#34; # High&#34;,
                           &#34;cpu.SP += 2&#34;])
        else:
            if left.operand.endswith(&#39;F&#39;): # Catching AF
                fmask = &#34; &amp; 0xF0&#34;
            else:
                fmask = &#34;&#34;
            # See comment from PUSH
            code.addline(&#34;cpu.%s = cpu.mb.getitem(cpu.SP+1) # High&#34; % left.operand[-2])
            if left.operand == &#34;AF&#34;:
                code.addline(&#34;cpu.%s = cpu.mb.getitem(cpu.SP)%s &amp; 0xF0 # Low&#34;
                             % (left.operand[-1], fmask))
            else:
                code.addline(&#34;cpu.%s = cpu.mb.getitem(cpu.SP)%s # Low&#34;
                             % (left.operand[-1], fmask))
            code.addline(&#34;cpu.SP += 2&#34;)

        return code.getcode()

    ###################################################################
    #
    # CONTROL FLOW OPERATIONS
    #
    def JP(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = None
            right = Operand(r1)

        r_code = right.get
        if left is not None:
            l_code = left.get
            if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
                left.flag = True
                l_code = &#34;cpu.f_c()&#34;
            assert left.flag
        elif right.pointer:
            # FIX: Wrongful syntax of &#34;JP (HL)&#34; actually meaning &#34;JP HL&#34;
            right.pointer = False
            r_code = right.codegen(False, operand=&#34;HL&#34;)
        else:
            assert right.immediate

        code = Code(self.name.split()[0], self.opcode, self.name, right.immediate, self.length,
                    self.cycles, branch_op=True)
        if left is None:
            code.addlines([
                &#34;cpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else r_code),
                &#34;return &#34; + self.cycles[0]
            ])
        else:
            code.addlines([
                &#34;if %s:&#34; % l_code,
                &#34;\tcpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else r_code),
                &#34;\treturn &#34; + self.cycles[0],
                &#34;else:&#34;,
                &#34;\tcpu.PC += %s&#34; % self.length,
                &#34;\treturn &#34; + self.cycles[1]
            ])

        return code.getcode()

    def JR(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = None
            right = Operand(r1)

        if left is not None:
            l_code = left.get
            if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
                left.flag = True
                l_code = &#34;cpu.f_c()&#34;
            assert left.flag
        assert right.immediate

        code = Code(self.name.split()[0], self.opcode, self.name, right.immediate, self.length,
                    self.cycles, branch_op=True)
        if left is None:
            code.addlines([
                &#34;cpu.PC += %d + &#34; % self.length + inline_signed_int8(&#34;v&#34;),
                &#34;cpu.PC &amp;= 0xFFFF&#34;,
                &#34;return &#34; + self.cycles[0]])
        else:
            code.addlines([
                &#34;cpu.PC += %d&#34; % self.length,
                &#34;if %s:&#34; % l_code,
                &#34;\tcpu.PC += &#34; + inline_signed_int8(&#34;v&#34;),
                &#34;\tcpu.PC &amp;= 0xFFFF&#34;,
                &#34;\treturn &#34; + self.cycles[0],
                &#34;else:&#34;,
                &#34;\tcpu.PC &amp;= 0xFFFF&#34;,
                &#34;\treturn &#34; + self.cycles[1]])

        return code.getcode()

    def CALL(self):
        if self.name.find(&#39;,&#39;) &gt; 0:
            r0, r1 = self.name.split()[1].split(&#34;,&#34;)
            left = Operand(r0)
            right = Operand(r1)
        else:
            r1 = self.name.split()[1]
            left = None
            right = Operand(r1)

        if left is not None:
            l_code = left.get
            if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
                left.flag = True
                l_code = &#34;cpu.f_c()&#34;
            assert left.flag
        assert right.immediate

        code = Code(self.name.split()[0], self.opcode, self.name, right.immediate, self.length,
                    self.cycles, branch_op=True)

        # Taken from PUSH
        code.addlines([
            &#34;cpu.PC += %s&#34; % self.length,
            &#34;cpu.PC &amp;= 0xFFFF&#34;])

        if left is None:
            code.addlines([
                &#34;cpu.mb.setitem(cpu.SP-1, cpu.PC &gt;&gt; 8) # High&#34;,
                &#34;cpu.mb.setitem(cpu.SP-2, cpu.PC &amp; 0xFF) # Low&#34;,
                &#34;cpu.SP -= 2&#34;,
                &#34;cpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else right.get),
                &#34;return &#34; + self.cycles[0]])
        else:
            code.addlines([
                &#34;if %s:&#34; % l_code,
                &#34;\tcpu.mb.setitem(cpu.SP-1, cpu.PC &gt;&gt; 8) # High&#34;,
                &#34;\tcpu.mb.setitem(cpu.SP-2, cpu.PC &amp; 0xFF) # Low&#34;,
                &#34;\tcpu.SP -= 2&#34;,
                &#34;\tcpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else right.get),
                &#34;\treturn &#34; + self.cycles[0],
                &#34;else:&#34;,
                &#34;\treturn &#34; + self.cycles[1]])

        return code.getcode()

    def RET(self):
        if self.name == &#34;RET&#34;:
            left = None
        else:
            r0 = self.name.split()[1]
            left = Operand(r0)

            l_code = left.get
            if left is not None:
                if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
                    left.flag = True
                    l_code = &#34;cpu.f_c()&#34;
                assert left.flag

        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles,
                    branch_op=True)
        if left is None:
            code.addlines([
                &#34;cpu.PC = cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8 # High&#34;,
                &#34;cpu.PC |= cpu.mb.getitem(cpu.SP) # Low&#34;,
                &#34;cpu.SP += 2&#34;,
                &#34;return &#34; + self.cycles[0]])
        else:
            code.addlines([
                &#34;if %s:&#34; % l_code,
                &#34;\tcpu.PC = cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8 # High&#34;,
                &#34;\tcpu.PC |= cpu.mb.getitem(cpu.SP) # Low&#34;,
                &#34;\tcpu.SP += 2&#34;,
                &#34;\treturn &#34; + self.cycles[0],
                &#34;else:&#34;,
                &#34;\tcpu.PC += %s&#34; % self.length,
                &#34;\tcpu.PC &amp;= 0xFFFF&#34;,
                &#34;\treturn &#34; + self.cycles[1]])

        return code.getcode()

    def RETI(self):
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles,
                    branch_op=True)
        code.addline(&#34;cpu.interrupt_master_enable = True&#34;)
        code.addlines([
            &#34;cpu.PC = cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8 # High&#34;,
            &#34;cpu.PC |= cpu.mb.getitem(cpu.SP) # Low&#34;,
            &#34;cpu.SP += 2&#34;,
            &#34;return &#34; + self.cycles[0]])

        return code.getcode()

    def RST(self):
        r1 = self.name.split()[1]
        right = Literal(r1)

        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles,
                    branch_op=True)

        # Taken from PUSH and CALL
        code.addlines([
            &#34;cpu.PC += %s&#34; % self.length,
            &#34;cpu.mb.setitem(cpu.SP-1, cpu.PC &gt;&gt; 8) # High&#34;,
            &#34;cpu.mb.setitem(cpu.SP-2, cpu.PC &amp; 0xFF) # Low&#34;,
            &#34;cpu.SP -= 2&#34;])

        code.addlines([
            &#34;cpu.PC = %s&#34; % (right.code),
            &#34;return &#34; + self.cycles[0]])

        return code.getcode()

    ###################################################################
    #
    # ROTATE/SHIFT OPERATIONS
    #
    def rotateleft(self, name, left, throughcarry=False):
        code = Code(name, self.opcode, self.name, False, self.length, self.cycles)
        left.assign = False
        if throughcarry:
            code.addline((&#34;t = (%s &lt;&lt; 1)&#34; % left.get) + &#34; + cpu.f_c()&#34;)
        else:
            code.addline(&#34;t = (%s &lt;&lt; 1) + (%s &gt;&gt; 7)&#34; % (left.get, left.get))
        code.addlines(self.handleflags8bit(left.get, None, None, throughcarry))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        left.assign = True
        code.addline(left.set % &#34;t&#34;)
        return code

    def RLA(self):
        left = Operand(&#39;A&#39;)
        code = self.rotateleft(self.name.split()[0], left, throughcarry=True)
        return code.getcode()

    def RLCA(self):
        left = Operand(&#39;A&#39;)
        code = self.rotateleft(self.name.split()[0], left)
        return code.getcode()

    def RLC(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = self.rotateleft(self.name.split()[0], left)
        return code.getcode()

    def RL(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = self.rotateleft(self.name.split()[0], left, throughcarry=True)
        return code.getcode()

    def rotateright(self, name, left, throughcarry=False):
        code = Code(name, self.opcode, self.name, False, self.length, self.cycles)
        left.assign = False
        if throughcarry:
            # Trigger &#34;overflow&#34; for carry flag
            code.addline((&#34;t = (%s &gt;&gt; 1)&#34; % left.get) +
                         &#34; + (cpu.f_c() &lt;&lt; 7)&#34; + &#34; + ((%s &amp; 1) &lt;&lt; 8)&#34; % (left.get))
        else:
            # Trigger &#34;overflow&#34; for carry flag
            code.addline(&#34;t = (%s &gt;&gt; 1) + ((%s &amp; 1) &lt;&lt; 7)&#34; % (left.get, left.get)
                         + &#34; + ((%s &amp; 1) &lt;&lt; 8)&#34; % (left.get))
        code.addlines(self.handleflags8bit(left.get, None, None, throughcarry))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        code.addline(left.set % &#34;t&#34;)
        return code

    def RRA(self):
        left = Operand(&#39;A&#39;)
        code = self.rotateright(self.name.split()[0], left, throughcarry=True)
        return code.getcode()

    def RRCA(self):
        left = Operand(&#39;A&#39;)
        code = self.rotateright(self.name.split()[0], left)
        return code.getcode()

    def RRC(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = self.rotateright(self.name.split()[0], left)
        return code.getcode()

    def RR(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = self.rotateright(self.name.split()[0], left, throughcarry=True)
        return code.getcode()

    def SLA(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(&#34;t = (%s &lt;&lt; 1)&#34; % left.get)
        code.addlines(self.handleflags8bit(left.get, None, None, False))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        code.addline(left.set % &#34;t&#34;)
        return code.getcode()

    def SRA(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        # FIX: All documentation tells it should have carry enabled
        self.flag_c = &#39;C&#39;
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        # Actual shift / MSB unchanged / Trigger &#34;overflow&#34; for carry flag
        code.addline(&#34;t = ((%s &gt;&gt; 1) | (%s &amp; 0x80)) + ((%s &amp; 1) &lt;&lt; 8)&#34;
                     % (left.get, left.get, left.get))
        code.addlines(self.handleflags8bit(left.get, None, None, False))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        code.addline(left.set % &#34;t&#34;)
        return code.getcode()

    def SRL(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        #              Actual shift / Trigger &#34;overflow&#34; for carry flag
        code.addline(&#34;t = (%s &gt;&gt; 1) + ((%s &amp; 1) &lt;&lt; 8)&#34; % (left.get, left.get))
        code.addlines(self.handleflags8bit(left.get, None, None, False))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        code.addline(left.set % &#34;t&#34;)
        return code.getcode()

    def SWAP(self):
        r0 = self.name.split()[1]
        left = Operand(r0)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(&#34;t = ((%s &amp; 0xF0) &gt;&gt; 4) | ((%s &amp; 0x0F) &lt;&lt; 4)&#34; % (left.get, left.get))
        code.addlines(self.handleflags8bit(left.get, None, None, False))
        code.addline(&#34;t &amp;= 0xFF&#34;)
        code.addline(left.set % &#34;t&#34;)
        return code.getcode()

    ###################################################################
    #
    # BIT OPERATIONS
    #
    def BIT(self):
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Literal(r0)
        right = Operand(r1)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(&#34;t = %s &amp; (1 &lt;&lt; %s)&#34; % (right.get, left.get))
        code.addlines(self.handleflags8bit(left.get, right.get, None, False))

        return code.getcode()

    def RES(self):
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Literal(r0)
        right = Operand(r1)

        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(&#34;t = %s &amp; ~(1 &lt;&lt; %s)&#34; % (right.get, left.get))
        code.addline(right.set % &#34;t&#34;)
        return code.getcode()

    def SET(self):
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Literal(r0)
        right = Operand(r1)
        code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
        code.addline(&#34;t = %s | (1 &lt;&lt; %s)&#34; % (right.get, left.get))
        code.addline(right.set % &#34;t&#34;)
        return code.getcode()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyboy.core.opcodes_gen.OpcodeData.ADC"><code class="name flex">
<span>def <span class="ident">ADC</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ADC(self):
    if self.name.find(&#39;,&#39;) &gt; 0:
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)
    else:
        r1 = self.name.split()[1]
        left = Operand(&#39;A&#39;)
        right = Operand(r1)

    code = Code(self.name.split()[0], self.opcode, self.name,
                left.immediate or right.immediate, self.length, self.cycles)
    code.addlines(self.ALU(left, right, &#39;+&#39;, carry=True))
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.ADD"><code class="name flex">
<span>def <span class="ident">ADD</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ADD(self):
    if self.name.find(&#39;,&#39;) &gt; 0:
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)
    else:
        r1 = self.name.split()[1]
        left = Operand(&#39;A&#39;)
        right = Operand(r1)

    code = Code(self.name.split()[0], self.opcode, self.name,
                left.immediate or right.immediate, self.length, self.cycles)
    code.addlines(self.ALU(left, right, &#39;+&#39;))
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.ALU"><code class="name flex">
<span>def <span class="ident">ALU</span></span>(<span>self, left, right, op, carry=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ALU(self, left, right, op, carry=False):
    lines = []

    left.assign = False
    right.assign = False
    calc = &#34; &#34;.join([&#34;t&#34;, &#34;=&#34;, left.get, op, right.get])

    if carry:
        calc += &#34; &#34; + op + &#34; cpu.f_c()&#34;

    lines.append(calc)

    if self.opcode == 0xE8:
        # E8 and F8 http://forums.nesdev.com/viewtopic.php?p=42138
        lines.extend(self.handleflags16bit_E8_F8(left.get, &#34;v&#34;, op, carry))
        lines.append(&#34;t &amp;= 0xFFFF&#34;)
    elif self.is16bit:
        lines.extend(self.handleflags16bit(left.get, right.get, op, carry))
        lines.append(&#34;t &amp;= 0xFFFF&#34;)
    else:
        lines.extend(self.handleflags8bit(left.get, right.get, op, carry))
        lines.append(&#34;t &amp;= 0xFF&#34;)

    # HAS TO BE THE LAST INSTRUCTION BECAUSE OF CP!
    lines.append(left.set % &#34;t&#34;)
    return lines</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.AND"><code class="name flex">
<span>def <span class="ident">AND</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def AND(self):
    if self.name.find(&#39;,&#39;) &gt; 0:
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)
    else:
        r1 = self.name.split()[1]
        left = Operand(&#39;A&#39;)
        right = Operand(r1)

    code = Code(self.name.split()[0], self.opcode, self.name,
                left.immediate or right.immediate, self.length, self.cycles)
    code.addlines(self.ALU(left, right, &#39;&amp;&#39;))
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.BIT"><code class="name flex">
<span>def <span class="ident">BIT</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def BIT(self):
    r0, r1 = self.name.split()[1].split(&#34;,&#34;)
    left = Literal(r0)
    right = Operand(r1)
    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    code.addline(&#34;t = %s &amp; (1 &lt;&lt; %s)&#34; % (right.get, left.get))
    code.addlines(self.handleflags8bit(left.get, right.get, None, False))

    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.CALL"><code class="name flex">
<span>def <span class="ident">CALL</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def CALL(self):
    if self.name.find(&#39;,&#39;) &gt; 0:
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)
    else:
        r1 = self.name.split()[1]
        left = None
        right = Operand(r1)

    if left is not None:
        l_code = left.get
        if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
            left.flag = True
            l_code = &#34;cpu.f_c()&#34;
        assert left.flag
    assert right.immediate

    code = Code(self.name.split()[0], self.opcode, self.name, right.immediate, self.length,
                self.cycles, branch_op=True)

    # Taken from PUSH
    code.addlines([
        &#34;cpu.PC += %s&#34; % self.length,
        &#34;cpu.PC &amp;= 0xFFFF&#34;])

    if left is None:
        code.addlines([
            &#34;cpu.mb.setitem(cpu.SP-1, cpu.PC &gt;&gt; 8) # High&#34;,
            &#34;cpu.mb.setitem(cpu.SP-2, cpu.PC &amp; 0xFF) # Low&#34;,
            &#34;cpu.SP -= 2&#34;,
            &#34;cpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else right.get),
            &#34;return &#34; + self.cycles[0]])
    else:
        code.addlines([
            &#34;if %s:&#34; % l_code,
            &#34;\tcpu.mb.setitem(cpu.SP-1, cpu.PC &gt;&gt; 8) # High&#34;,
            &#34;\tcpu.mb.setitem(cpu.SP-2, cpu.PC &amp; 0xFF) # Low&#34;,
            &#34;\tcpu.SP -= 2&#34;,
            &#34;\tcpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else right.get),
            &#34;\treturn &#34; + self.cycles[0],
            &#34;else:&#34;,
            &#34;\treturn &#34; + self.cycles[1]])

    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.CB"><code class="name flex">
<span>def <span class="ident">CB</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def CB(self):
    code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
    code.addline(&#34;raise Exception(&#39;CB cannot be called!&#39;)&#34;)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.CCF"><code class="name flex">
<span>def <span class="ident">CCF</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def CCF(self):
    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    code.addlines([
        &#34;flag = (cpu.F &amp; 0b00010000) ^ 0b00010000&#34;,
        &#34;cpu.F &amp;= 0b10000000&#34;,
        &#34;cpu.F |= flag&#34;,
    ])
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.CP"><code class="name flex">
<span>def <span class="ident">CP</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def CP(self):
    r1 = self.name.split()[1]
    left = Operand(&#39;A&#39;)
    right = Operand(r1)

    code = Code(self.name.split()[0], self.opcode, self.name,
                left.immediate or right.immediate, self.length, self.cycles)
    # CP is equal to SUB, but without saving the result.
    # Therefore; we discard the last instruction.
    code.addlines(self.ALU(left, right, &#39;-&#39;)[:-1])
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.CPL"><code class="name flex">
<span>def <span class="ident">CPL</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def CPL(self):
    left = Operand(&#39;A&#39;)
    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    code.addline(left.set % (&#34;(~%s) &amp; 0xFF&#34; % left.get))
    code.addlines(self.handleflags8bit(None, None, None))
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.DAA"><code class="name flex">
<span>def <span class="ident">DAA</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def DAA(self):
    left = Operand(&#39;A&#39;)
    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)

    # http://stackoverflow.com/a/29990058/3831206
    # http://forums.nesdev.com/viewtopic.php?t=9088
    code.addlines([
        &#34;t = %s&#34; % left.get,

        &#34;corr = 0&#34;,
        &#34;corr |= 0x06 if cpu.f_h() else 0x00&#34;,
        &#34;corr |= 0x60 if cpu.f_c() else 0x00&#34;,

        &#34;if cpu.f_n():&#34;,
        &#34;\tt -= corr&#34;,
        &#34;else:&#34;,
        &#34;\tcorr |= 0x06 if (t &amp; 0x0F) &gt; 0x09 else 0x00&#34;,
        &#34;\tcorr |= 0x60 if t &gt; 0x99 else 0x00&#34;,
        &#34;\tt += corr&#34;,

        &#34;flag = 0&#34;,
        &#34;flag += ((t &amp; 0xFF) == 0) &lt;&lt; FLAGZ&#34;,
        &#34;flag += (corr &amp; 0x60 != 0) &lt;&lt; FLAGC&#34;,
        &#34;cpu.F &amp;= 0b01000000&#34;,
        &#34;cpu.F |= flag&#34;,
        &#34;t &amp;= 0xFF&#34;,

        left.set % &#34;t&#34;
    ])
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.DEC"><code class="name flex">
<span>def <span class="ident">DEC</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def DEC(self):
    r0 = self.name.split()[1]
    left = Operand(r0)
    right = Literal(1)

    code = Code(self.name.split()[0], self.opcode, self.name,
                left.immediate or right.immediate, self.length, self.cycles)
    code.addlines(self.ALU(left, right, &#39;-&#39;))
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.DI"><code class="name flex">
<span>def <span class="ident">DI</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def DI(self):
    code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
    code.addline(&#34;cpu.interrupt_master_enable = False&#34;)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.EI"><code class="name flex">
<span>def <span class="ident">EI</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def EI(self):
    code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
    code.addline(&#34;cpu.interrupt_master_enable = True&#34;)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.HALT"><code class="name flex">
<span>def <span class="ident">HALT</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def HALT(self):
    code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles,
                branch_op=True)

    # TODO: Implement HALT bug. If master interrupt is disabled,
    # the intruction following HALT is skipped
    code.addlines([
        &#34;if cpu.interrupt_master_enable:&#34;,
        &#34;\tcpu.halted = True&#34;,
        &#34;else:&#34;,
        &#34;\tcpu.PC += 1&#34;,
        &#34;return &#34; + self.cycles[0]
    ])
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.INC"><code class="name flex">
<span>def <span class="ident">INC</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def INC(self):
    r0 = self.name.split()[1]
    left = Operand(r0)
    right = Literal(1)

    code = Code(self.name.split()[0], self.opcode, self.name,
                left.immediate or right.immediate, self.length, self.cycles)
    code.addlines(self.ALU(left, right, &#39;+&#39;))
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.JP"><code class="name flex">
<span>def <span class="ident">JP</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def JP(self):
    if self.name.find(&#39;,&#39;) &gt; 0:
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)
    else:
        r1 = self.name.split()[1]
        left = None
        right = Operand(r1)

    r_code = right.get
    if left is not None:
        l_code = left.get
        if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
            left.flag = True
            l_code = &#34;cpu.f_c()&#34;
        assert left.flag
    elif right.pointer:
        # FIX: Wrongful syntax of &#34;JP (HL)&#34; actually meaning &#34;JP HL&#34;
        right.pointer = False
        r_code = right.codegen(False, operand=&#34;HL&#34;)
    else:
        assert right.immediate

    code = Code(self.name.split()[0], self.opcode, self.name, right.immediate, self.length,
                self.cycles, branch_op=True)
    if left is None:
        code.addlines([
            &#34;cpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else r_code),
            &#34;return &#34; + self.cycles[0]
        ])
    else:
        code.addlines([
            &#34;if %s:&#34; % l_code,
            &#34;\tcpu.PC = %s&#34; % (&#39;v&#39; if right.immediate else r_code),
            &#34;\treturn &#34; + self.cycles[0],
            &#34;else:&#34;,
            &#34;\tcpu.PC += %s&#34; % self.length,
            &#34;\treturn &#34; + self.cycles[1]
        ])

    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.JR"><code class="name flex">
<span>def <span class="ident">JR</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def JR(self):
    if self.name.find(&#39;,&#39;) &gt; 0:
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)
    else:
        r1 = self.name.split()[1]
        left = None
        right = Operand(r1)

    if left is not None:
        l_code = left.get
        if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
            left.flag = True
            l_code = &#34;cpu.f_c()&#34;
        assert left.flag
    assert right.immediate

    code = Code(self.name.split()[0], self.opcode, self.name, right.immediate, self.length,
                self.cycles, branch_op=True)
    if left is None:
        code.addlines([
            &#34;cpu.PC += %d + &#34; % self.length + inline_signed_int8(&#34;v&#34;),
            &#34;cpu.PC &amp;= 0xFFFF&#34;,
            &#34;return &#34; + self.cycles[0]])
    else:
        code.addlines([
            &#34;cpu.PC += %d&#34; % self.length,
            &#34;if %s:&#34; % l_code,
            &#34;\tcpu.PC += &#34; + inline_signed_int8(&#34;v&#34;),
            &#34;\tcpu.PC &amp;= 0xFFFF&#34;,
            &#34;\treturn &#34; + self.cycles[0],
            &#34;else:&#34;,
            &#34;\tcpu.PC &amp;= 0xFFFF&#34;,
            &#34;\treturn &#34; + self.cycles[1]])

    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.LD"><code class="name flex">
<span>def <span class="ident">LD</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def LD(self):
    r0, r1 = self.name.split()[1].split(&#34;,&#34;)
    left = Operand(r0)
    right = Operand(r1)

    # FIX: There seems to be a wrong opcode length on E2 and F2
    if self.opcode == 0xE2 or self.opcode == 0xF2:
        self.length = 1

    code = Code(self.name.split()[0], self.opcode, self.name,
                left.immediate or right.immediate, self.length, self.cycles)
    if self.is16bit and left.immediate and left.pointer:
        code.addline(left.set % (&#34;%s &amp; 0xFF&#34; % right.get))
        a, b = left.set.split(&#34;,&#34;)
        code.addline((a + &#34;+1,&#34; + b) % (&#34;%s &gt;&gt; 8&#34; % right.get))
    else:
        # Special handling of AF, BC, DE
        # print(left.set, right.get, hex(self.opcode))
        code.addline(left.set % right.get)

    # Special HL-only operations
    if left.postoperation is not None:
        code.addline(left.postoperation)
    elif right.postoperation is not None:
        code.addline(right.postoperation)
    elif self.opcode == 0xF8:
        # E8 and F8 http://forums.nesdev.com/viewtopic.php?p=42138
        code.addline(&#34;t = cpu.HL&#34;)
        code.addlines(self.handleflags16bit_E8_F8(&#34;cpu.SP&#34;, &#34;v&#34;, &#39;+&#39;, False))
        code.addline(&#34;cpu.HL &amp;= 0xFFFF&#34;)

    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.LDH"><code class="name flex">
<span>def <span class="ident">LDH</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def LDH(self):
    return self.LD()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.NOP"><code class="name flex">
<span>def <span class="ident">NOP</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def NOP(self):
    code = Code(self.name.split()[0], self.opcode, self.name, 0, self.length, self.cycles)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.OR"><code class="name flex">
<span>def <span class="ident">OR</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def OR(self):
    if self.name.find(&#39;,&#39;) &gt; 0:
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)
    else:
        r1 = self.name.split()[1]
        left = Operand(&#39;A&#39;)
        right = Operand(r1)

    code = Code(self.name.split()[0], self.opcode, self.name,
                left.immediate or right.immediate, self.length, self.cycles)
    code.addlines(self.ALU(left, right, &#39;|&#39;))
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.POP"><code class="name flex">
<span>def <span class="ident">POP</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def POP(self):
    r0 = self.name.split()[1]
    left = Operand(r0)

    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    if &#34;HL&#34; in left.get:
        code.addlines([(left.set % &#34;(cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8) + &#34;
                        &#34;cpu.mb.getitem(cpu.SP)&#34;) + &#34; # High&#34;,
                       &#34;cpu.SP += 2&#34;])
    else:
        if left.operand.endswith(&#39;F&#39;): # Catching AF
            fmask = &#34; &amp; 0xF0&#34;
        else:
            fmask = &#34;&#34;
        # See comment from PUSH
        code.addline(&#34;cpu.%s = cpu.mb.getitem(cpu.SP+1) # High&#34; % left.operand[-2])
        if left.operand == &#34;AF&#34;:
            code.addline(&#34;cpu.%s = cpu.mb.getitem(cpu.SP)%s &amp; 0xF0 # Low&#34;
                         % (left.operand[-1], fmask))
        else:
            code.addline(&#34;cpu.%s = cpu.mb.getitem(cpu.SP)%s # Low&#34;
                         % (left.operand[-1], fmask))
        code.addline(&#34;cpu.SP += 2&#34;)

    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.PUSH"><code class="name flex">
<span>def <span class="ident">PUSH</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def PUSH(self):
    r0 = self.name.split()[1]
    left = Operand(r0)

    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    if &#34;HL&#34; in left.get:
        code.addlines([
            &#34;cpu.mb.setitem(cpu.SP-1, cpu.HL &gt;&gt; 8) # High&#34;,
            &#34;cpu.mb.setitem(cpu.SP-2, cpu.HL &amp; 0xFF) # Low&#34;,
            &#34;cpu.SP -= 2&#34;])
    else:
        # A bit of a hack, but you can only push double registers
        code.addline(&#34;cpu.mb.setitem(cpu.SP-1, cpu.%s) # High&#34; % left.operand[-2])
        if left.operand == &#34;AF&#34;:
            # by taking fx &#39;A&#39; and &#39;F&#39; directly, we save calculations
            code.addline(&#34;cpu.mb.setitem(cpu.SP-2, cpu.%s &amp; 0xF0) # Low&#34;
                         % left.operand[-1])
        else:
            # by taking fx &#39;A&#39; and &#39;F&#39; directly, we save calculations
            code.addline(&#34;cpu.mb.setitem(cpu.SP-2, cpu.%s) # Low&#34; % left.operand[-1])
        code.addline(&#34;cpu.SP -= 2&#34;)

    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RES"><code class="name flex">
<span>def <span class="ident">RES</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RES(self):
    r0, r1 = self.name.split()[1].split(&#34;,&#34;)
    left = Literal(r0)
    right = Operand(r1)

    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    code.addline(&#34;t = %s &amp; ~(1 &lt;&lt; %s)&#34; % (right.get, left.get))
    code.addline(right.set % &#34;t&#34;)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RET"><code class="name flex">
<span>def <span class="ident">RET</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RET(self):
    if self.name == &#34;RET&#34;:
        left = None
    else:
        r0 = self.name.split()[1]
        left = Operand(r0)

        l_code = left.get
        if left is not None:
            if l_code.endswith(&#34;C&#34;) and &#34;NC&#34; not in l_code:
                left.flag = True
                l_code = &#34;cpu.f_c()&#34;
            assert left.flag

    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles,
                branch_op=True)
    if left is None:
        code.addlines([
            &#34;cpu.PC = cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8 # High&#34;,
            &#34;cpu.PC |= cpu.mb.getitem(cpu.SP) # Low&#34;,
            &#34;cpu.SP += 2&#34;,
            &#34;return &#34; + self.cycles[0]])
    else:
        code.addlines([
            &#34;if %s:&#34; % l_code,
            &#34;\tcpu.PC = cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8 # High&#34;,
            &#34;\tcpu.PC |= cpu.mb.getitem(cpu.SP) # Low&#34;,
            &#34;\tcpu.SP += 2&#34;,
            &#34;\treturn &#34; + self.cycles[0],
            &#34;else:&#34;,
            &#34;\tcpu.PC += %s&#34; % self.length,
            &#34;\tcpu.PC &amp;= 0xFFFF&#34;,
            &#34;\treturn &#34; + self.cycles[1]])

    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RETI"><code class="name flex">
<span>def <span class="ident">RETI</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RETI(self):
    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles,
                branch_op=True)
    code.addline(&#34;cpu.interrupt_master_enable = True&#34;)
    code.addlines([
        &#34;cpu.PC = cpu.mb.getitem(cpu.SP+1) &lt;&lt; 8 # High&#34;,
        &#34;cpu.PC |= cpu.mb.getitem(cpu.SP) # Low&#34;,
        &#34;cpu.SP += 2&#34;,
        &#34;return &#34; + self.cycles[0]])

    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RL"><code class="name flex">
<span>def <span class="ident">RL</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RL(self):
    r0 = self.name.split()[1]
    left = Operand(r0)
    code = self.rotateleft(self.name.split()[0], left, throughcarry=True)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RLA"><code class="name flex">
<span>def <span class="ident">RLA</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RLA(self):
    left = Operand(&#39;A&#39;)
    code = self.rotateleft(self.name.split()[0], left, throughcarry=True)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RLC"><code class="name flex">
<span>def <span class="ident">RLC</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RLC(self):
    r0 = self.name.split()[1]
    left = Operand(r0)
    code = self.rotateleft(self.name.split()[0], left)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RLCA"><code class="name flex">
<span>def <span class="ident">RLCA</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RLCA(self):
    left = Operand(&#39;A&#39;)
    code = self.rotateleft(self.name.split()[0], left)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RR"><code class="name flex">
<span>def <span class="ident">RR</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RR(self):
    r0 = self.name.split()[1]
    left = Operand(r0)
    code = self.rotateright(self.name.split()[0], left, throughcarry=True)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RRA"><code class="name flex">
<span>def <span class="ident">RRA</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RRA(self):
    left = Operand(&#39;A&#39;)
    code = self.rotateright(self.name.split()[0], left, throughcarry=True)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RRC"><code class="name flex">
<span>def <span class="ident">RRC</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RRC(self):
    r0 = self.name.split()[1]
    left = Operand(r0)
    code = self.rotateright(self.name.split()[0], left)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RRCA"><code class="name flex">
<span>def <span class="ident">RRCA</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RRCA(self):
    left = Operand(&#39;A&#39;)
    code = self.rotateright(self.name.split()[0], left)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.RST"><code class="name flex">
<span>def <span class="ident">RST</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def RST(self):
    r1 = self.name.split()[1]
    right = Literal(r1)

    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles,
                branch_op=True)

    # Taken from PUSH and CALL
    code.addlines([
        &#34;cpu.PC += %s&#34; % self.length,
        &#34;cpu.mb.setitem(cpu.SP-1, cpu.PC &gt;&gt; 8) # High&#34;,
        &#34;cpu.mb.setitem(cpu.SP-2, cpu.PC &amp; 0xFF) # Low&#34;,
        &#34;cpu.SP -= 2&#34;])

    code.addlines([
        &#34;cpu.PC = %s&#34; % (right.code),
        &#34;return &#34; + self.cycles[0]])

    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.SBC"><code class="name flex">
<span>def <span class="ident">SBC</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def SBC(self):
    if self.name.find(&#39;,&#39;) &gt; 0:
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)
    else:
        r1 = self.name.split()[1]
        left = Operand(&#39;A&#39;)
        right = Operand(r1)

    code = Code(self.name.split()[0], self.opcode, self.name,
                left.immediate or right.immediate, self.length, self.cycles)
    code.addlines(self.ALU(left, right, &#39;-&#39;, carry=True))
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.SCF"><code class="name flex">
<span>def <span class="ident">SCF</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def SCF(self):
    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    code.addlines(self.handleflags8bit(None, None, None))
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.SET"><code class="name flex">
<span>def <span class="ident">SET</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def SET(self):
    r0, r1 = self.name.split()[1].split(&#34;,&#34;)
    left = Literal(r0)
    right = Operand(r1)
    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    code.addline(&#34;t = %s | (1 &lt;&lt; %s)&#34; % (right.get, left.get))
    code.addline(right.set % &#34;t&#34;)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.SLA"><code class="name flex">
<span>def <span class="ident">SLA</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def SLA(self):
    r0 = self.name.split()[1]
    left = Operand(r0)
    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    code.addline(&#34;t = (%s &lt;&lt; 1)&#34; % left.get)
    code.addlines(self.handleflags8bit(left.get, None, None, False))
    code.addline(&#34;t &amp;= 0xFF&#34;)
    code.addline(left.set % &#34;t&#34;)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.SRA"><code class="name flex">
<span>def <span class="ident">SRA</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def SRA(self):
    r0 = self.name.split()[1]
    left = Operand(r0)
    # FIX: All documentation tells it should have carry enabled
    self.flag_c = &#39;C&#39;
    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    # Actual shift / MSB unchanged / Trigger &#34;overflow&#34; for carry flag
    code.addline(&#34;t = ((%s &gt;&gt; 1) | (%s &amp; 0x80)) + ((%s &amp; 1) &lt;&lt; 8)&#34;
                 % (left.get, left.get, left.get))
    code.addlines(self.handleflags8bit(left.get, None, None, False))
    code.addline(&#34;t &amp;= 0xFF&#34;)
    code.addline(left.set % &#34;t&#34;)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.SRL"><code class="name flex">
<span>def <span class="ident">SRL</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def SRL(self):
    r0 = self.name.split()[1]
    left = Operand(r0)
    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    #              Actual shift / Trigger &#34;overflow&#34; for carry flag
    code.addline(&#34;t = (%s &gt;&gt; 1) + ((%s &amp; 1) &lt;&lt; 8)&#34; % (left.get, left.get))
    code.addlines(self.handleflags8bit(left.get, None, None, False))
    code.addline(&#34;t &amp;= 0xFF&#34;)
    code.addline(left.set % &#34;t&#34;)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.STOP"><code class="name flex">
<span>def <span class="ident">STOP</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def STOP(self):
    code = Code(self.name.split()[0], self.opcode, self.name, True, self.length, self.cycles)
    code.addline(&#34;pass&#34;)
    # code.addLine(&#34;raise Exception(&#39;STOP not implemented!&#39;)&#34;)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.SUB"><code class="name flex">
<span>def <span class="ident">SUB</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def SUB(self):
    if self.name.find(&#39;,&#39;) &gt; 0:
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)
    else:
        r1 = self.name.split()[1]
        left = Operand(&#39;A&#39;)
        right = Operand(r1)

    code = Code(self.name.split()[0], self.opcode, self.name,
                left.immediate or right.immediate, self.length, self.cycles)
    code.addlines(self.ALU(left, right, &#39;-&#39;))
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.SWAP"><code class="name flex">
<span>def <span class="ident">SWAP</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def SWAP(self):
    r0 = self.name.split()[1]
    left = Operand(r0)
    code = Code(self.name.split()[0], self.opcode, self.name, False, self.length, self.cycles)
    code.addline(&#34;t = ((%s &amp; 0xF0) &gt;&gt; 4) | ((%s &amp; 0x0F) &lt;&lt; 4)&#34; % (left.get, left.get))
    code.addlines(self.handleflags8bit(left.get, None, None, False))
    code.addline(&#34;t &amp;= 0xFF&#34;)
    code.addline(left.set % &#34;t&#34;)
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.XOR"><code class="name flex">
<span>def <span class="ident">XOR</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def XOR(self):
    if self.name.find(&#39;,&#39;) &gt; 0:
        r0, r1 = self.name.split()[1].split(&#34;,&#34;)
        left = Operand(r0)
        right = Operand(r1)
    else:
        r1 = self.name.split()[1]
        left = Operand(&#39;A&#39;)
        right = Operand(r1)

    code = Code(self.name.split()[0], self.opcode, self.name,
                left.immediate or right.immediate, self.length, self.cycles)
    code.addlines(self.ALU(left, right, &#39;^&#39;))
    return code.getcode()</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.createfunction"><code class="name flex">
<span>def <span class="ident">createfunction</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def createfunction(self):
    text = self.functionhandlers[self.name.split()[0]]()
    # Compensate for CB operations being &#34;2 bytes long&#34;
    if self.opcode &gt; 0xFF:
        self.length -= 1
    return (self.length, &#34;%s_%0.2X&#34; % (self.name.split()[0], self.opcode), self.name), text</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.handleflags16bit"><code class="name flex">
<span>def <span class="ident">handleflags16bit</span></span>(<span>self, r0, r1, op, carry=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handleflags16bit(self, r0, r1, op, carry=False):
    flagmask = sum(map(lambda nf: (nf[1] == &#34;-&#34;) &lt;&lt; (nf[0]+4), self.flags))

    # Only in case we do a dynamic operation, do we include the
    # following calculations
    if flagmask == 0b11110000:
        return [&#34;# No flag operations&#34;]

    lines = []
    # Sets the ones that always get set by operation
    lines.append(&#34;flag = &#34; + format(sum(map(lambda nf: (nf[1] == &#34;1&#34;) &lt;&lt; (nf[0]+4),
                                            self.flags)), &#34;#010b&#34;))

    if self.flag_h == &#34;H&#34;:
        c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
        lines.append(&#34;flag += (((%s &amp; 0xFFF) %s (%s &amp; 0xFFF)%s) &gt; 0xFFF) &lt;&lt; FLAGH&#34;
                     % (r0, op, r1, c))

    if self.flag_c == &#34;C&#34;:
        lines.append(&#34;flag += (t &gt; 0xFFFF) &lt;&lt; FLAGC&#34;)

    # Clears all flags affected by the operation
    lines.append(&#34;cpu.F &amp;= &#34; + format(flagmask, &#34;#010b&#34;))
    lines.append(&#34;cpu.F |= flag&#34;)
    return lines</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.handleflags16bit_E8_F8"><code class="name flex">
<span>def <span class="ident">handleflags16bit_E8_F8</span></span>(<span>self, r0, r1, op, carry=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handleflags16bit_E8_F8(self, r0, r1, op, carry=False):
    flagmask = sum(map(lambda nf: (nf[1] == &#34;-&#34;) &lt;&lt; (nf[0]+4), self.flags))

    # Only in case we do a dynamic operation, do we include the
    # following calculations
    if flagmask == 0b11110000:
        return [&#34;# No flag operations&#34;]

    lines = []
    # Sets the flags that always get set by operation
    lines.append(&#34;flag = &#34; + format(sum(map(lambda nf: (nf[1] == &#34;1&#34;) &lt;&lt; (nf[0]+4),
                                            self.flags)), &#34;#010b&#34;))

    # flag += (((cpu.SP &amp; 0xF) + (v &amp; 0xF)) &gt; 0xF) &lt;&lt; FLAGH
    if self.flag_h == &#34;H&#34;:
        c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
        lines.append(&#34;flag += (((%s &amp; 0xF) %s (%s &amp; 0xF)%s) &gt; 0xF) &lt;&lt; FLAGH&#34;
                     % (r0, op, r1, c))

    # flag += (((cpu.SP &amp; 0xFF) + (v &amp; 0xFF)) &gt; 0xFF) &lt;&lt; FLAGC
    if self.flag_c == &#34;C&#34;:
        lines.append(&#34;flag += (((%s &amp; 0xFF) %s (%s &amp; 0xFF)%s) &gt; 0xFF) &lt;&lt; FLAGC&#34;
                     % (r0, op, r1, c))

    # Clears all flags affected by the operation
    lines.append(&#34;cpu.F &amp;= &#34; + format(flagmask, &#34;#010b&#34;))
    lines.append(&#34;cpu.F |= flag&#34;)
    return lines</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.handleflags8bit"><code class="name flex">
<span>def <span class="ident">handleflags8bit</span></span>(<span>self, r0, r1, op, carry=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handleflags8bit(self, r0, r1, op, carry=False):
    flagmask = sum(map(lambda nf: (nf[1] == &#34;-&#34;) &lt;&lt; (nf[0]+4), self.flags))

    # Only in case we do a dynamic operation, do we include the
    # following calculations
    if flagmask == 0b11110000:
        return [&#34;# No flag operations&#34;]

    lines = []
    # Sets the ones that always get set by operation
    lines.append(&#34;flag = &#34; + format(sum(map(lambda nf: (nf[1] == &#34;1&#34;) &lt;&lt; (nf[0]+4),
                                            self.flags)), &#34;#010b&#34;))

    if self.flag_z == &#34;Z&#34;:
        lines.append(&#34;flag += ((t &amp; 0xFF) == 0) &lt;&lt; FLAGZ&#34;)

    if self.flag_h == &#34;H&#34; and op == &#39;-&#39;:
        c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
        lines.append(&#34;flag += (((%s &amp; 0xF) %s (%s &amp; 0xF)%s) &lt; 0) &lt;&lt; FLAGH&#34;
                     % (r0, op, r1, c))
    elif self.flag_h == &#34;H&#34;:
        c = &#34; %s cpu.f_c()&#34; % op if carry else &#34;&#34;
        lines.append(&#34;flag += (((%s &amp; 0xF) %s (%s &amp; 0xF)%s) &gt; 0xF) &lt;&lt; FLAGH&#34;
                     % (r0, op, r1, c))

    if self.flag_c == &#34;C&#34; and op == &#39;-&#39;:
        lines.append(&#34;flag += (t &lt; 0) &lt;&lt; FLAGC&#34;)
    elif self.flag_c == &#34;C&#34;:
        lines.append(&#34;flag += (t &gt; 0xFF) &lt;&lt; FLAGC&#34;)

    # Clears all flags affected by the operation
    lines.append(&#34;cpu.F &amp;= &#34; + format(flagmask, &#34;#010b&#34;))
    lines.append(&#34;cpu.F |= flag&#34;)
    return lines</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.rotateleft"><code class="name flex">
<span>def <span class="ident">rotateleft</span></span>(<span>self, name, left, throughcarry=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rotateleft(self, name, left, throughcarry=False):
    code = Code(name, self.opcode, self.name, False, self.length, self.cycles)
    left.assign = False
    if throughcarry:
        code.addline((&#34;t = (%s &lt;&lt; 1)&#34; % left.get) + &#34; + cpu.f_c()&#34;)
    else:
        code.addline(&#34;t = (%s &lt;&lt; 1) + (%s &gt;&gt; 7)&#34; % (left.get, left.get))
    code.addlines(self.handleflags8bit(left.get, None, None, throughcarry))
    code.addline(&#34;t &amp;= 0xFF&#34;)
    left.assign = True
    code.addline(left.set % &#34;t&#34;)
    return code</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.OpcodeData.rotateright"><code class="name flex">
<span>def <span class="ident">rotateright</span></span>(<span>self, name, left, throughcarry=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rotateright(self, name, left, throughcarry=False):
    code = Code(name, self.opcode, self.name, False, self.length, self.cycles)
    left.assign = False
    if throughcarry:
        # Trigger &#34;overflow&#34; for carry flag
        code.addline((&#34;t = (%s &gt;&gt; 1)&#34; % left.get) +
                     &#34; + (cpu.f_c() &lt;&lt; 7)&#34; + &#34; + ((%s &amp; 1) &lt;&lt; 8)&#34; % (left.get))
    else:
        # Trigger &#34;overflow&#34; for carry flag
        code.addline(&#34;t = (%s &gt;&gt; 1) + ((%s &amp; 1) &lt;&lt; 7)&#34; % (left.get, left.get)
                     + &#34; + ((%s &amp; 1) &lt;&lt; 8)&#34; % (left.get))
    code.addlines(self.handleflags8bit(left.get, None, None, throughcarry))
    code.addline(&#34;t &amp;= 0xFF&#34;)
    code.addline(left.set % &#34;t&#34;)
    return code</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.core.opcodes_gen.Operand"><code class="flex name class">
<span>class <span class="ident">Operand</span></span>
<span>(</span><span>operand)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Operand:
    def __init__(self, operand):
        self.postoperation = None
        self.pointer = False
        self.highpointer = False
        self.immediate = False
        self.signed = False
        self.is16bit = False
        self.flag = False
        self.operand = operand
        self.codegen(False)

    @property
    def set(self):
        return self.codegen(True)

    @property
    def get(self):
        return self.codegen(False)

    def codegen(self, assign, operand=None):
        if operand is None:
            operand = self.operand

        if operand == &#34;(C)&#34;:
            self.highpointer = True
            if assign:
                return &#34;cpu.mb.setitem(0xFF00 + cpu.C, %s)&#34;
            else:
                return &#34;cpu.mb.getitem(0xFF00 + cpu.C)&#34;

        elif operand == &#34;SP+r8&#34;:
            self.immediate = True
            self.signed = True

            # post operation set in LD handler!
            return &#34;cpu.SP + &#34; + inline_signed_int8(&#34;v&#34;)

        elif operand.startswith(&#39;(&#39;) and operand.endswith(&#39;)&#39;):
            self.pointer = True
            if assign:
                code = &#34;cpu.mb.setitem(%s&#34; % self.codegen(False, operand=re.search(
                    r&#39;\(([a-zA-Z]+\d*)[\+-]?\)&#39;, operand).group(1)) + &#34;, %s)&#34;
            else:
                code = &#34;cpu.mb.getitem(%s)&#34; % self.codegen(False, operand=re.search(
                    r&#39;\(([a-zA-Z]+\d*)[\+-]?\)&#39;, operand).group(1))

            if &#39;-&#39; in operand or &#39;+&#39; in operand:
                # TODO: Replace with opcode 23 (INC HL)?
                self.postoperation = &#34;cpu.HL %s= 1&#34; % operand[-2]

            return code

        # Sadly, there is an overlap between the register &#39;C&#39; and to
        # check for the carry flag &#39;C&#39;.
        elif operand in [
                &#39;A&#39;, &#39;F&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, # registers
                &#39;SP&#39;, &#39;PC&#39;, &#39;HL&#39;]:             # double registers
            if assign:
                return &#34;cpu.&#34; + operand + &#34; = %s&#34;
            else:
                return &#34;cpu.&#34; + operand

        elif operand == &#39;H&#39;:
            if assign:
                return &#34;cpu.HL = (cpu.HL &amp; 0x00FF) | (%s &lt;&lt; 8)&#34;
            else:
                return &#34;(cpu.HL &gt;&gt; 8)&#34;

        elif operand == &#39;L&#39;:
            if assign:
                return &#34;cpu.HL = (cpu.HL &amp; 0xFF00) | (%s &amp; 0xFF)&#34;
            else:
                return &#34;(cpu.HL &amp; 0xFF)&#34;

        elif operand in [&#39;AF&#39;, &#39;BC&#39;, &#39;DE&#39;]:
            if assign:
                return &#34;cpu.set_&#34; + operand.lower() + &#34;(%s)&#34;
            else:
                return &#34;((cpu.&#34; + operand[0] + &#34; &lt;&lt; 8) + cpu.&#34; + operand[1] + &#34;)&#34;

        elif operand in [&#39;Z&#39;, &#39;C&#39;, &#39;NZ&#39;, &#39;NC&#39;]: # flags
            assert not assign
            self.flag = True
            return &#34;cpu.f_&#34; + operand.lower() + &#34;()&#34;

        elif operand in [&#39;d8&#39;, &#39;d16&#39;, &#39;a8&#39;, &#39;a16&#39;, &#39;r8&#39;]:
            assert not assign
            code = &#34;v&#34;
            self.immediate = True

            if operand == &#39;r8&#39;:
                code = inline_signed_int8(code)
                self.signed = True
            elif operand == &#39;a8&#39;:
                code += &#34; + 0xFF00&#34;
                self.highpointer = True
            return code

        else:
            raise ValueError(&#34;Didn&#39;t match symbol: %s&#34; % operand)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyboy.core.opcodes_gen.Operand.get"><code class="name">var <span class="ident">get</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def get(self):
    return self.codegen(False)</code></pre>
</details>
</dd>
<dt id="pyboy.core.opcodes_gen.Operand.set"><code class="name">var <span class="ident">set</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def set(self):
    return self.codegen(True)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyboy.core.opcodes_gen.Operand.codegen"><code class="name flex">
<span>def <span class="ident">codegen</span></span>(<span>self, assign, operand=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def codegen(self, assign, operand=None):
    if operand is None:
        operand = self.operand

    if operand == &#34;(C)&#34;:
        self.highpointer = True
        if assign:
            return &#34;cpu.mb.setitem(0xFF00 + cpu.C, %s)&#34;
        else:
            return &#34;cpu.mb.getitem(0xFF00 + cpu.C)&#34;

    elif operand == &#34;SP+r8&#34;:
        self.immediate = True
        self.signed = True

        # post operation set in LD handler!
        return &#34;cpu.SP + &#34; + inline_signed_int8(&#34;v&#34;)

    elif operand.startswith(&#39;(&#39;) and operand.endswith(&#39;)&#39;):
        self.pointer = True
        if assign:
            code = &#34;cpu.mb.setitem(%s&#34; % self.codegen(False, operand=re.search(
                r&#39;\(([a-zA-Z]+\d*)[\+-]?\)&#39;, operand).group(1)) + &#34;, %s)&#34;
        else:
            code = &#34;cpu.mb.getitem(%s)&#34; % self.codegen(False, operand=re.search(
                r&#39;\(([a-zA-Z]+\d*)[\+-]?\)&#39;, operand).group(1))

        if &#39;-&#39; in operand or &#39;+&#39; in operand:
            # TODO: Replace with opcode 23 (INC HL)?
            self.postoperation = &#34;cpu.HL %s= 1&#34; % operand[-2]

        return code

    # Sadly, there is an overlap between the register &#39;C&#39; and to
    # check for the carry flag &#39;C&#39;.
    elif operand in [
            &#39;A&#39;, &#39;F&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, # registers
            &#39;SP&#39;, &#39;PC&#39;, &#39;HL&#39;]:             # double registers
        if assign:
            return &#34;cpu.&#34; + operand + &#34; = %s&#34;
        else:
            return &#34;cpu.&#34; + operand

    elif operand == &#39;H&#39;:
        if assign:
            return &#34;cpu.HL = (cpu.HL &amp; 0x00FF) | (%s &lt;&lt; 8)&#34;
        else:
            return &#34;(cpu.HL &gt;&gt; 8)&#34;

    elif operand == &#39;L&#39;:
        if assign:
            return &#34;cpu.HL = (cpu.HL &amp; 0xFF00) | (%s &amp; 0xFF)&#34;
        else:
            return &#34;(cpu.HL &amp; 0xFF)&#34;

    elif operand in [&#39;AF&#39;, &#39;BC&#39;, &#39;DE&#39;]:
        if assign:
            return &#34;cpu.set_&#34; + operand.lower() + &#34;(%s)&#34;
        else:
            return &#34;((cpu.&#34; + operand[0] + &#34; &lt;&lt; 8) + cpu.&#34; + operand[1] + &#34;)&#34;

    elif operand in [&#39;Z&#39;, &#39;C&#39;, &#39;NZ&#39;, &#39;NC&#39;]: # flags
        assert not assign
        self.flag = True
        return &#34;cpu.f_&#34; + operand.lower() + &#34;()&#34;

    elif operand in [&#39;d8&#39;, &#39;d16&#39;, &#39;a8&#39;, &#39;a16&#39;, &#39;r8&#39;]:
        assert not assign
        code = &#34;v&#34;
        self.immediate = True

        if operand == &#39;r8&#39;:
            code = inline_signed_int8(code)
            self.signed = True
        elif operand == &#39;a8&#39;:
            code += &#34; + 0xFF00&#34;
            self.highpointer = True
        return code

    else:
        raise ValueError(&#34;Didn&#39;t match symbol: %s&#34; % operand)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyboy.core" href="index.html">pyboy.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyboy.core.opcodes_gen.inline_signed_int8" href="#pyboy.core.opcodes_gen.inline_signed_int8">inline_signed_int8</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.load" href="#pyboy.core.opcodes_gen.load">load</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.update" href="#pyboy.core.opcodes_gen.update">update</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyboy.core.opcodes_gen.Code" href="#pyboy.core.opcodes_gen.Code">Code</a></code></h4>
<ul class="">
<li><code><a title="pyboy.core.opcodes_gen.Code.addline" href="#pyboy.core.opcodes_gen.Code.addline">addline</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.Code.addlines" href="#pyboy.core.opcodes_gen.Code.addlines">addlines</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.Code.getcode" href="#pyboy.core.opcodes_gen.Code.getcode">getcode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.core.opcodes_gen.Literal" href="#pyboy.core.opcodes_gen.Literal">Literal</a></code></h4>
<ul class="">
<li><code><a title="pyboy.core.opcodes_gen.Literal.get" href="#pyboy.core.opcodes_gen.Literal.get">get</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.core.opcodes_gen.MyHTMLParser" href="#pyboy.core.opcodes_gen.MyHTMLParser">MyHTMLParser</a></code></h4>
<ul class="">
<li><code><a title="pyboy.core.opcodes_gen.MyHTMLParser.handle_data" href="#pyboy.core.opcodes_gen.MyHTMLParser.handle_data">handle_data</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.MyHTMLParser.handle_endtag" href="#pyboy.core.opcodes_gen.MyHTMLParser.handle_endtag">handle_endtag</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.MyHTMLParser.handle_starttag" href="#pyboy.core.opcodes_gen.MyHTMLParser.handle_starttag">handle_starttag</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.MyHTMLParser.make_opcode" href="#pyboy.core.opcodes_gen.MyHTMLParser.make_opcode">make_opcode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.core.opcodes_gen.OpcodeData" href="#pyboy.core.opcodes_gen.OpcodeData">OpcodeData</a></code></h4>
<ul class="">
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.ADC" href="#pyboy.core.opcodes_gen.OpcodeData.ADC">ADC</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.ADD" href="#pyboy.core.opcodes_gen.OpcodeData.ADD">ADD</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.ALU" href="#pyboy.core.opcodes_gen.OpcodeData.ALU">ALU</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.AND" href="#pyboy.core.opcodes_gen.OpcodeData.AND">AND</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.BIT" href="#pyboy.core.opcodes_gen.OpcodeData.BIT">BIT</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.CALL" href="#pyboy.core.opcodes_gen.OpcodeData.CALL">CALL</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.CB" href="#pyboy.core.opcodes_gen.OpcodeData.CB">CB</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.CCF" href="#pyboy.core.opcodes_gen.OpcodeData.CCF">CCF</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.CP" href="#pyboy.core.opcodes_gen.OpcodeData.CP">CP</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.CPL" href="#pyboy.core.opcodes_gen.OpcodeData.CPL">CPL</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.DAA" href="#pyboy.core.opcodes_gen.OpcodeData.DAA">DAA</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.DEC" href="#pyboy.core.opcodes_gen.OpcodeData.DEC">DEC</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.DI" href="#pyboy.core.opcodes_gen.OpcodeData.DI">DI</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.EI" href="#pyboy.core.opcodes_gen.OpcodeData.EI">EI</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.HALT" href="#pyboy.core.opcodes_gen.OpcodeData.HALT">HALT</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.INC" href="#pyboy.core.opcodes_gen.OpcodeData.INC">INC</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.JP" href="#pyboy.core.opcodes_gen.OpcodeData.JP">JP</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.JR" href="#pyboy.core.opcodes_gen.OpcodeData.JR">JR</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.LD" href="#pyboy.core.opcodes_gen.OpcodeData.LD">LD</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.LDH" href="#pyboy.core.opcodes_gen.OpcodeData.LDH">LDH</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.NOP" href="#pyboy.core.opcodes_gen.OpcodeData.NOP">NOP</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.OR" href="#pyboy.core.opcodes_gen.OpcodeData.OR">OR</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.POP" href="#pyboy.core.opcodes_gen.OpcodeData.POP">POP</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.PUSH" href="#pyboy.core.opcodes_gen.OpcodeData.PUSH">PUSH</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RES" href="#pyboy.core.opcodes_gen.OpcodeData.RES">RES</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RET" href="#pyboy.core.opcodes_gen.OpcodeData.RET">RET</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RETI" href="#pyboy.core.opcodes_gen.OpcodeData.RETI">RETI</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RL" href="#pyboy.core.opcodes_gen.OpcodeData.RL">RL</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RLA" href="#pyboy.core.opcodes_gen.OpcodeData.RLA">RLA</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RLC" href="#pyboy.core.opcodes_gen.OpcodeData.RLC">RLC</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RLCA" href="#pyboy.core.opcodes_gen.OpcodeData.RLCA">RLCA</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RR" href="#pyboy.core.opcodes_gen.OpcodeData.RR">RR</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RRA" href="#pyboy.core.opcodes_gen.OpcodeData.RRA">RRA</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RRC" href="#pyboy.core.opcodes_gen.OpcodeData.RRC">RRC</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RRCA" href="#pyboy.core.opcodes_gen.OpcodeData.RRCA">RRCA</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.RST" href="#pyboy.core.opcodes_gen.OpcodeData.RST">RST</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.SBC" href="#pyboy.core.opcodes_gen.OpcodeData.SBC">SBC</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.SCF" href="#pyboy.core.opcodes_gen.OpcodeData.SCF">SCF</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.SET" href="#pyboy.core.opcodes_gen.OpcodeData.SET">SET</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.SLA" href="#pyboy.core.opcodes_gen.OpcodeData.SLA">SLA</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.SRA" href="#pyboy.core.opcodes_gen.OpcodeData.SRA">SRA</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.SRL" href="#pyboy.core.opcodes_gen.OpcodeData.SRL">SRL</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.STOP" href="#pyboy.core.opcodes_gen.OpcodeData.STOP">STOP</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.SUB" href="#pyboy.core.opcodes_gen.OpcodeData.SUB">SUB</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.SWAP" href="#pyboy.core.opcodes_gen.OpcodeData.SWAP">SWAP</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.XOR" href="#pyboy.core.opcodes_gen.OpcodeData.XOR">XOR</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.createfunction" href="#pyboy.core.opcodes_gen.OpcodeData.createfunction">createfunction</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.handleflags16bit" href="#pyboy.core.opcodes_gen.OpcodeData.handleflags16bit">handleflags16bit</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.handleflags16bit_E8_F8" href="#pyboy.core.opcodes_gen.OpcodeData.handleflags16bit_E8_F8">handleflags16bit_E8_F8</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.handleflags8bit" href="#pyboy.core.opcodes_gen.OpcodeData.handleflags8bit">handleflags8bit</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.rotateleft" href="#pyboy.core.opcodes_gen.OpcodeData.rotateleft">rotateleft</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.OpcodeData.rotateright" href="#pyboy.core.opcodes_gen.OpcodeData.rotateright">rotateright</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.core.opcodes_gen.Operand" href="#pyboy.core.opcodes_gen.Operand">Operand</a></code></h4>
<ul class="">
<li><code><a title="pyboy.core.opcodes_gen.Operand.codegen" href="#pyboy.core.opcodes_gen.Operand.codegen">codegen</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.Operand.get" href="#pyboy.core.opcodes_gen.Operand.get">get</a></code></li>
<li><code><a title="pyboy.core.opcodes_gen.Operand.set" href="#pyboy.core.opcodes_gen.Operand.set">set</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>