<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>pyboy.plugins.rewind API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyboy.plugins.rewind</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#
# License: See LICENSE file
# GitHub: https://github.com/Baekalfen/PyBoy
#

import array
import logging

from pyboy.plugins.base_plugin import PyBoyPlugin
from pyboy.utils import IntIOInterface, WindowEvent

logger = logging.getLogger(__name__)

try:
    from cython import compiled
    cythonmode = compiled
except ImportError:
    cythonmode = False


FIXED_BUFFER_SIZE = 64*1024*128
FIXED_BUFFER_MIN_ALLOC = 64*1024
FILL_VALUE = 123


class Rewind(PyBoyPlugin):
    argv = [(&#39;--rewind&#39;, {&#34;action&#34;: &#39;store_true&#39;, &#34;help&#34;: &#39;Enable rewind function&#39;})]

    def __init__(self, *args):
        super().__init__(*args)

        self.rewind_speed = 1.0
        self.rewind_buffer = DeltaFixedAllocBuffers()

    def post_tick(self):
        if not self.pyboy.paused:
            self.mb.save_state(self.rewind_buffer)
            self.rewind_buffer.new()

    def window_title(self):
        return &#34; Rewind: %0.2fKB/s&#34; % ((self.rewind_buffer.avg_section_size*60)/1024)

    def handle_events(self, events):
        old_rewind_speed = self.rewind_speed
        for event in events:
            if event == WindowEvent.UNPAUSE:
                self.rewind_buffer.commit()
            elif event == WindowEvent.PAUSE_TOGGLE:
                if self.pyboy.paused:
                    self.rewind_buffer.commit()
            elif event == WindowEvent.RELEASE_REWIND_FORWARD:
                self.rewind_speed = 1
            elif event == WindowEvent.PRESS_REWIND_FORWARD:
                self.pyboy._pause()
                if self.rewind_buffer.seek_frame(1):
                    self.mb.load_state(self.rewind_buffer)
                    events.append(WindowEvent._INTERNAL_RENDERER_FLUSH)
                    self.rewind_speed = min(self.rewind_speed * 1.1, 5)
                else:
                    logger.info(&#34;Rewind limit reached&#34;)
            elif event == WindowEvent.RELEASE_REWIND_BACK:
                self.rewind_speed = 1
            elif event == WindowEvent.PRESS_REWIND_BACK:
                self.pyboy._pause()
                if self.rewind_buffer.seek_frame(-1):
                    self.mb.load_state(self.rewind_buffer)
                    events.append(WindowEvent._INTERNAL_RENDERER_FLUSH)
                    self.rewind_speed = min(self.rewind_speed * 1.1, 5)
                else:
                    logger.info(&#34;Rewind limit reached&#34;)

        if old_rewind_speed != self.rewind_speed:
            # NOTE: Disable this line, if recording for .replay files
            self.pyboy.set_emulation_speed(int(self.rewind_speed))
        return events

    def enabled(self):
        return self.pyboy_argv.get(&#39;rewind&#39;)


##############################################################
# Homogeneous cyclic buffer
##############################################################


class FixedAllocBuffers(IntIOInterface):
    def __init__(self):
        self.buffer = _malloc(FIXED_BUFFER_SIZE) # NOQA: F821
        for n in range(FIXED_BUFFER_SIZE):
            self.buffer[n] = FILL_VALUE
        self.sections = [0]
        self.current_section = 0
        self.tail_pointer = 0
        # self.head_pointer = 0
        self.section_head = 0
        self.section_tail = 0
        self.section_pointer = 0
        self.avg_section_size = 0.0

    def stop(self):
        _free(self.buffer) # NOQA: F821

    def flush(self):
        pass

    def new(self):
        self.flush()
        # print(self.section_pointer-self.sections[-1]) # Find the actual length of the state in memory
        self.sections.append(self.section_pointer)
        self.current_section += 1
        section_size = (self.section_head - self.section_tail + FIXED_BUFFER_SIZE) % FIXED_BUFFER_SIZE
        # Exponentially decaying moving average
        self.avg_section_size = (0.9 * self.avg_section_size) + (0.1 * section_size)
        self.section_tail = self.section_pointer

    def write(self, val):
        assert val &lt; 0x100
        if (self.section_pointer + 1) % FIXED_BUFFER_SIZE == self.tail_pointer:
            # We have reached the back of the buffer. We remove the first section to make room.
            self.sections = self.sections[1:]
            self.tail_pointer = self.sections[0]
            self.current_section -= 1
        self.buffer[self.section_pointer] = val
        self.section_pointer = (self.section_pointer + 1) % FIXED_BUFFER_SIZE
        self.section_head = self.section_pointer
        return 1

    def read(self):
        if self.section_pointer == self.section_head:
            raise Exception(&#34;Read beyond section&#34;)
        data = self.buffer[self.section_pointer]
        self.section_pointer = (self.section_pointer + 1) % FIXED_BUFFER_SIZE
        return data

    def commit(self):
        if not self.section_head == self.section_pointer:
            raise Exception(&#34;Section wasn&#39;t read to finish. This would likely be unintentional&#34;)
        self.sections = self.sections[:self.current_section+1]

    def seek_frame(self, frames):
        # TODO: Move for loop to Delta version
        for _ in range(abs(frames)):
            if frames &lt; 0:
                if self.current_section &lt; 1:
                    return False

                # Decrement the active section and fetch its pointer position
                head = self.sections[self.current_section]
                self.current_section -= 1
                tail = self.sections[self.current_section]
            else:
                if self.current_section == len(self.sections)-1:
                    return False

                # Increment the active section and fetch its pointer position
                tail = self.sections[self.current_section]
                self.current_section += 1
                head = self.sections[self.current_section]

        # Refine the new head and tail
        self.section_tail, self.section_head = tail, head

        # Seeks the section to 0, ready for reading
        self.section_pointer = self.section_tail
        return True


class CompressedFixedAllocBuffers(FixedAllocBuffers):
    def __init__(self):
        FixedAllocBuffers.__init__(self)
        self.zeros = 0

    def flush(self):
        if self.zeros &gt; 0:
            chunks = self.zeros // 0xFF
            rest = self.zeros % 0xFF

            for i in range(chunks):
                FixedAllocBuffers.write(self, 0)
                FixedAllocBuffers.write(self, 0xFF)

            if (rest != 0):
                FixedAllocBuffers.write(self, 0)
                FixedAllocBuffers.write(self, rest)

        self.zeros = 0
        FixedAllocBuffers.flush(self)

    def write(self, data):
        if data == 0:
            self.zeros += 1
            return 1
        else:
            self.flush()
            return FixedAllocBuffers.write(self, data)

    def read(self):
        if self.zeros &gt; 0:
            self.zeros -= 1
            return 0
        else:
            byte = FixedAllocBuffers.read(self)
            if byte == 0:
                # If the bytes is zero, it means that the next byte will be the counter
                self.zeros = FixedAllocBuffers.read(self)
                self.zeros -= 1
            return byte

    def new(self):
        FixedAllocBuffers.new(self)

    def commit(self):
        FixedAllocBuffers.commit(self)

    def seek_frame(self, v):
        return FixedAllocBuffers.seek_frame(self, v)


class DeltaFixedAllocBuffers(CompressedFixedAllocBuffers):
    &#34;&#34;&#34;
    I chose to keep the code simple at the expense of some edge cases acting different from the other buffers.
    When seeking, the last frame will be lost. This has no practical effect, and is only noticeble in unittesting.
    &#34;&#34;&#34;
    def __init__(self):
        CompressedFixedAllocBuffers.__init__(self)
        self.internal_pointer = 0
        self.prev_internal_pointer = 0
        # The initial values needs to be 0 to act as the &#34;null-frame&#34; and make the first frame a one-to-one copy
        # TODO: It would work with any values, but it makes it easier to debug
        self.internal_buffer = array.array(&#39;B&#39;, [0]*FIXED_BUFFER_MIN_ALLOC)
        self.internal_buffer_dirty = False

        # A side effect of the implementation will create a zero-frame in the beginning. Keep track of this,
        # as we don&#39;t want to use the section until we rollover the circular buffer.
        self.base_frame = 0
        # The frame we inject in the end to flush the last frame out
        self.injected_zero_frame = 0

    def write(self, data):
        self.internal_buffer_dirty = True
        old_val = self.internal_buffer[self.internal_pointer]
        xor_val = data ^ old_val
        self.internal_buffer[self.internal_pointer] = data
        self.internal_pointer += 1
        return CompressedFixedAllocBuffers.write(self, xor_val)

    def read(self):
        old_val = CompressedFixedAllocBuffers.read(self)
        data = old_val ^ self.internal_buffer[self.internal_pointer]
        self.internal_buffer[self.internal_pointer] = data
        self.internal_pointer += 1
        return data

    def commit(self):
        self.internal_pointer = 0
        self.injected_zero_frame = 0
        CompressedFixedAllocBuffers.commit(self)

    def new(self):
        self.prev_internal_pointer = self.internal_pointer
        self.internal_pointer = 0
        CompressedFixedAllocBuffers.new(self)

    def flush_internal_buffer(self):
        # self.current_section += 1
        for n in range(self.prev_internal_pointer):
            CompressedFixedAllocBuffers.write(self, self.internal_buffer[n])
            # Make a null-frame so we can XOR the newest frame back in
            self.internal_buffer[n] = 0
        self.internal_buffer_dirty = False
        CompressedFixedAllocBuffers.new(self)
        self.injected_zero_frame = self.current_section

    def seek_frame(self, frames):
        # for _ in range(abs(frames)):
        # TODO: Can only seek one frame
        if frames &lt; 0:
            frames = -1
        else:
            frames = 1

        # Flush internal buffer to underlying memory. Otherwise, the newest frame, won&#39;t be seekable.
        if self.internal_buffer_dirty:
            self.flush_internal_buffer()
        self.internal_pointer = 0

        if frames &gt; 0 and self.injected_zero_frame-1 == self.current_section:
            return False
        elif frames &lt; 0 and self.current_section-1 == self.base_frame:
            return False

        return CompressedFixedAllocBuffers.seek_frame(self, frames)


# Having this in the top of the file, causes glitces in Vim&#39;s syntax highlighting
if not cythonmode:
    exec(&#34;&#34;&#34;
def _malloc(n):
    return array.array(&#39;B&#39;, [0]*(FIXED_BUFFER_SIZE))

def _free(_):
    pass
&#34;&#34;&#34;, globals(), locals())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyboy.plugins.rewind.CompressedFixedAllocBuffers"><code class="flex name class">
<span>class <span class="ident">CompressedFixedAllocBuffers</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CompressedFixedAllocBuffers(FixedAllocBuffers):
    def __init__(self):
        FixedAllocBuffers.__init__(self)
        self.zeros = 0

    def flush(self):
        if self.zeros &gt; 0:
            chunks = self.zeros // 0xFF
            rest = self.zeros % 0xFF

            for i in range(chunks):
                FixedAllocBuffers.write(self, 0)
                FixedAllocBuffers.write(self, 0xFF)

            if (rest != 0):
                FixedAllocBuffers.write(self, 0)
                FixedAllocBuffers.write(self, rest)

        self.zeros = 0
        FixedAllocBuffers.flush(self)

    def write(self, data):
        if data == 0:
            self.zeros += 1
            return 1
        else:
            self.flush()
            return FixedAllocBuffers.write(self, data)

    def read(self):
        if self.zeros &gt; 0:
            self.zeros -= 1
            return 0
        else:
            byte = FixedAllocBuffers.read(self)
            if byte == 0:
                # If the bytes is zero, it means that the next byte will be the counter
                self.zeros = FixedAllocBuffers.read(self)
                self.zeros -= 1
            return byte

    def new(self):
        FixedAllocBuffers.new(self)

    def commit(self):
        FixedAllocBuffers.commit(self)

    def seek_frame(self, v):
        return FixedAllocBuffers.seek_frame(self, v)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyboy.plugins.rewind.FixedAllocBuffers</li>
<li>pyboy.utils.IntIOInterface</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyboy.plugins.rewind.DeltaFixedAllocBuffers</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyboy.plugins.rewind.CompressedFixedAllocBuffers.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def commit(self):
    FixedAllocBuffers.commit(self)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.CompressedFixedAllocBuffers.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def flush(self):
    if self.zeros &gt; 0:
        chunks = self.zeros // 0xFF
        rest = self.zeros % 0xFF

        for i in range(chunks):
            FixedAllocBuffers.write(self, 0)
            FixedAllocBuffers.write(self, 0xFF)

        if (rest != 0):
            FixedAllocBuffers.write(self, 0)
            FixedAllocBuffers.write(self, rest)

    self.zeros = 0
    FixedAllocBuffers.flush(self)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.CompressedFixedAllocBuffers.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def new(self):
    FixedAllocBuffers.new(self)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.CompressedFixedAllocBuffers.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read(self):
    if self.zeros &gt; 0:
        self.zeros -= 1
        return 0
    else:
        byte = FixedAllocBuffers.read(self)
        if byte == 0:
            # If the bytes is zero, it means that the next byte will be the counter
            self.zeros = FixedAllocBuffers.read(self)
            self.zeros -= 1
        return byte</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.CompressedFixedAllocBuffers.seek_frame"><code class="name flex">
<span>def <span class="ident">seek_frame</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def seek_frame(self, v):
    return FixedAllocBuffers.seek_frame(self, v)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.CompressedFixedAllocBuffers.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write(self, data):
    if data == 0:
        self.zeros += 1
        return 1
    else:
        self.flush()
        return FixedAllocBuffers.write(self, data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.plugins.rewind.DeltaFixedAllocBuffers"><code class="flex name class">
<span>class <span class="ident">DeltaFixedAllocBuffers</span></span>
</code></dt>
<dd>
<section class="desc"><p>I chose to keep the code simple at the expense of some edge cases acting different from the other buffers.
When seeking, the last frame will be lost. This has no practical effect, and is only noticeble in unittesting.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class DeltaFixedAllocBuffers(CompressedFixedAllocBuffers):
    &#34;&#34;&#34;
    I chose to keep the code simple at the expense of some edge cases acting different from the other buffers.
    When seeking, the last frame will be lost. This has no practical effect, and is only noticeble in unittesting.
    &#34;&#34;&#34;
    def __init__(self):
        CompressedFixedAllocBuffers.__init__(self)
        self.internal_pointer = 0
        self.prev_internal_pointer = 0
        # The initial values needs to be 0 to act as the &#34;null-frame&#34; and make the first frame a one-to-one copy
        # TODO: It would work with any values, but it makes it easier to debug
        self.internal_buffer = array.array(&#39;B&#39;, [0]*FIXED_BUFFER_MIN_ALLOC)
        self.internal_buffer_dirty = False

        # A side effect of the implementation will create a zero-frame in the beginning. Keep track of this,
        # as we don&#39;t want to use the section until we rollover the circular buffer.
        self.base_frame = 0
        # The frame we inject in the end to flush the last frame out
        self.injected_zero_frame = 0

    def write(self, data):
        self.internal_buffer_dirty = True
        old_val = self.internal_buffer[self.internal_pointer]
        xor_val = data ^ old_val
        self.internal_buffer[self.internal_pointer] = data
        self.internal_pointer += 1
        return CompressedFixedAllocBuffers.write(self, xor_val)

    def read(self):
        old_val = CompressedFixedAllocBuffers.read(self)
        data = old_val ^ self.internal_buffer[self.internal_pointer]
        self.internal_buffer[self.internal_pointer] = data
        self.internal_pointer += 1
        return data

    def commit(self):
        self.internal_pointer = 0
        self.injected_zero_frame = 0
        CompressedFixedAllocBuffers.commit(self)

    def new(self):
        self.prev_internal_pointer = self.internal_pointer
        self.internal_pointer = 0
        CompressedFixedAllocBuffers.new(self)

    def flush_internal_buffer(self):
        # self.current_section += 1
        for n in range(self.prev_internal_pointer):
            CompressedFixedAllocBuffers.write(self, self.internal_buffer[n])
            # Make a null-frame so we can XOR the newest frame back in
            self.internal_buffer[n] = 0
        self.internal_buffer_dirty = False
        CompressedFixedAllocBuffers.new(self)
        self.injected_zero_frame = self.current_section

    def seek_frame(self, frames):
        # for _ in range(abs(frames)):
        # TODO: Can only seek one frame
        if frames &lt; 0:
            frames = -1
        else:
            frames = 1

        # Flush internal buffer to underlying memory. Otherwise, the newest frame, won&#39;t be seekable.
        if self.internal_buffer_dirty:
            self.flush_internal_buffer()
        self.internal_pointer = 0

        if frames &gt; 0 and self.injected_zero_frame-1 == self.current_section:
            return False
        elif frames &lt; 0 and self.current_section-1 == self.base_frame:
            return False

        return CompressedFixedAllocBuffers.seek_frame(self, frames)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyboy.plugins.rewind.CompressedFixedAllocBuffers</li>
<li>pyboy.plugins.rewind.FixedAllocBuffers</li>
<li>pyboy.utils.IntIOInterface</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyboy.plugins.rewind.DeltaFixedAllocBuffers.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def commit(self):
    self.internal_pointer = 0
    self.injected_zero_frame = 0
    CompressedFixedAllocBuffers.commit(self)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.DeltaFixedAllocBuffers.flush_internal_buffer"><code class="name flex">
<span>def <span class="ident">flush_internal_buffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def flush_internal_buffer(self):
    # self.current_section += 1
    for n in range(self.prev_internal_pointer):
        CompressedFixedAllocBuffers.write(self, self.internal_buffer[n])
        # Make a null-frame so we can XOR the newest frame back in
        self.internal_buffer[n] = 0
    self.internal_buffer_dirty = False
    CompressedFixedAllocBuffers.new(self)
    self.injected_zero_frame = self.current_section</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.DeltaFixedAllocBuffers.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def new(self):
    self.prev_internal_pointer = self.internal_pointer
    self.internal_pointer = 0
    CompressedFixedAllocBuffers.new(self)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.DeltaFixedAllocBuffers.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read(self):
    old_val = CompressedFixedAllocBuffers.read(self)
    data = old_val ^ self.internal_buffer[self.internal_pointer]
    self.internal_buffer[self.internal_pointer] = data
    self.internal_pointer += 1
    return data</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.DeltaFixedAllocBuffers.seek_frame"><code class="name flex">
<span>def <span class="ident">seek_frame</span></span>(<span>self, frames)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def seek_frame(self, frames):
    # for _ in range(abs(frames)):
    # TODO: Can only seek one frame
    if frames &lt; 0:
        frames = -1
    else:
        frames = 1

    # Flush internal buffer to underlying memory. Otherwise, the newest frame, won&#39;t be seekable.
    if self.internal_buffer_dirty:
        self.flush_internal_buffer()
    self.internal_pointer = 0

    if frames &gt; 0 and self.injected_zero_frame-1 == self.current_section:
        return False
    elif frames &lt; 0 and self.current_section-1 == self.base_frame:
        return False

    return CompressedFixedAllocBuffers.seek_frame(self, frames)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.DeltaFixedAllocBuffers.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write(self, data):
    self.internal_buffer_dirty = True
    old_val = self.internal_buffer[self.internal_pointer]
    xor_val = data ^ old_val
    self.internal_buffer[self.internal_pointer] = data
    self.internal_pointer += 1
    return CompressedFixedAllocBuffers.write(self, xor_val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.plugins.rewind.FixedAllocBuffers"><code class="flex name class">
<span>class <span class="ident">FixedAllocBuffers</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class FixedAllocBuffers(IntIOInterface):
    def __init__(self):
        self.buffer = _malloc(FIXED_BUFFER_SIZE) # NOQA: F821
        for n in range(FIXED_BUFFER_SIZE):
            self.buffer[n] = FILL_VALUE
        self.sections = [0]
        self.current_section = 0
        self.tail_pointer = 0
        # self.head_pointer = 0
        self.section_head = 0
        self.section_tail = 0
        self.section_pointer = 0
        self.avg_section_size = 0.0

    def stop(self):
        _free(self.buffer) # NOQA: F821

    def flush(self):
        pass

    def new(self):
        self.flush()
        # print(self.section_pointer-self.sections[-1]) # Find the actual length of the state in memory
        self.sections.append(self.section_pointer)
        self.current_section += 1
        section_size = (self.section_head - self.section_tail + FIXED_BUFFER_SIZE) % FIXED_BUFFER_SIZE
        # Exponentially decaying moving average
        self.avg_section_size = (0.9 * self.avg_section_size) + (0.1 * section_size)
        self.section_tail = self.section_pointer

    def write(self, val):
        assert val &lt; 0x100
        if (self.section_pointer + 1) % FIXED_BUFFER_SIZE == self.tail_pointer:
            # We have reached the back of the buffer. We remove the first section to make room.
            self.sections = self.sections[1:]
            self.tail_pointer = self.sections[0]
            self.current_section -= 1
        self.buffer[self.section_pointer] = val
        self.section_pointer = (self.section_pointer + 1) % FIXED_BUFFER_SIZE
        self.section_head = self.section_pointer
        return 1

    def read(self):
        if self.section_pointer == self.section_head:
            raise Exception(&#34;Read beyond section&#34;)
        data = self.buffer[self.section_pointer]
        self.section_pointer = (self.section_pointer + 1) % FIXED_BUFFER_SIZE
        return data

    def commit(self):
        if not self.section_head == self.section_pointer:
            raise Exception(&#34;Section wasn&#39;t read to finish. This would likely be unintentional&#34;)
        self.sections = self.sections[:self.current_section+1]

    def seek_frame(self, frames):
        # TODO: Move for loop to Delta version
        for _ in range(abs(frames)):
            if frames &lt; 0:
                if self.current_section &lt; 1:
                    return False

                # Decrement the active section and fetch its pointer position
                head = self.sections[self.current_section]
                self.current_section -= 1
                tail = self.sections[self.current_section]
            else:
                if self.current_section == len(self.sections)-1:
                    return False

                # Increment the active section and fetch its pointer position
                tail = self.sections[self.current_section]
                self.current_section += 1
                head = self.sections[self.current_section]

        # Refine the new head and tail
        self.section_tail, self.section_head = tail, head

        # Seeks the section to 0, ready for reading
        self.section_pointer = self.section_tail
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyboy.utils.IntIOInterface</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyboy.plugins.rewind.CompressedFixedAllocBuffers</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyboy.plugins.rewind.FixedAllocBuffers.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def commit(self):
    if not self.section_head == self.section_pointer:
        raise Exception(&#34;Section wasn&#39;t read to finish. This would likely be unintentional&#34;)
    self.sections = self.sections[:self.current_section+1]</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.FixedAllocBuffers.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def flush(self):
    pass</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.FixedAllocBuffers.new"><code class="name flex">
<span>def <span class="ident">new</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def new(self):
    self.flush()
    # print(self.section_pointer-self.sections[-1]) # Find the actual length of the state in memory
    self.sections.append(self.section_pointer)
    self.current_section += 1
    section_size = (self.section_head - self.section_tail + FIXED_BUFFER_SIZE) % FIXED_BUFFER_SIZE
    # Exponentially decaying moving average
    self.avg_section_size = (0.9 * self.avg_section_size) + (0.1 * section_size)
    self.section_tail = self.section_pointer</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.FixedAllocBuffers.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read(self):
    if self.section_pointer == self.section_head:
        raise Exception(&#34;Read beyond section&#34;)
    data = self.buffer[self.section_pointer]
    self.section_pointer = (self.section_pointer + 1) % FIXED_BUFFER_SIZE
    return data</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.FixedAllocBuffers.seek_frame"><code class="name flex">
<span>def <span class="ident">seek_frame</span></span>(<span>self, frames)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def seek_frame(self, frames):
    # TODO: Move for loop to Delta version
    for _ in range(abs(frames)):
        if frames &lt; 0:
            if self.current_section &lt; 1:
                return False

            # Decrement the active section and fetch its pointer position
            head = self.sections[self.current_section]
            self.current_section -= 1
            tail = self.sections[self.current_section]
        else:
            if self.current_section == len(self.sections)-1:
                return False

            # Increment the active section and fetch its pointer position
            tail = self.sections[self.current_section]
            self.current_section += 1
            head = self.sections[self.current_section]

    # Refine the new head and tail
    self.section_tail, self.section_head = tail, head

    # Seeks the section to 0, ready for reading
    self.section_pointer = self.section_tail
    return True</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.FixedAllocBuffers.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def stop(self):
    _free(self.buffer) # NOQA: F821</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.FixedAllocBuffers.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write(self, val):
    assert val &lt; 0x100
    if (self.section_pointer + 1) % FIXED_BUFFER_SIZE == self.tail_pointer:
        # We have reached the back of the buffer. We remove the first section to make room.
        self.sections = self.sections[1:]
        self.tail_pointer = self.sections[0]
        self.current_section -= 1
    self.buffer[self.section_pointer] = val
    self.section_pointer = (self.section_pointer + 1) % FIXED_BUFFER_SIZE
    self.section_head = self.section_pointer
    return 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.plugins.rewind.Rewind"><code class="flex name class">
<span>class <span class="ident">Rewind</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Rewind(PyBoyPlugin):
    argv = [(&#39;--rewind&#39;, {&#34;action&#34;: &#39;store_true&#39;, &#34;help&#34;: &#39;Enable rewind function&#39;})]

    def __init__(self, *args):
        super().__init__(*args)

        self.rewind_speed = 1.0
        self.rewind_buffer = DeltaFixedAllocBuffers()

    def post_tick(self):
        if not self.pyboy.paused:
            self.mb.save_state(self.rewind_buffer)
            self.rewind_buffer.new()

    def window_title(self):
        return &#34; Rewind: %0.2fKB/s&#34; % ((self.rewind_buffer.avg_section_size*60)/1024)

    def handle_events(self, events):
        old_rewind_speed = self.rewind_speed
        for event in events:
            if event == WindowEvent.UNPAUSE:
                self.rewind_buffer.commit()
            elif event == WindowEvent.PAUSE_TOGGLE:
                if self.pyboy.paused:
                    self.rewind_buffer.commit()
            elif event == WindowEvent.RELEASE_REWIND_FORWARD:
                self.rewind_speed = 1
            elif event == WindowEvent.PRESS_REWIND_FORWARD:
                self.pyboy._pause()
                if self.rewind_buffer.seek_frame(1):
                    self.mb.load_state(self.rewind_buffer)
                    events.append(WindowEvent._INTERNAL_RENDERER_FLUSH)
                    self.rewind_speed = min(self.rewind_speed * 1.1, 5)
                else:
                    logger.info(&#34;Rewind limit reached&#34;)
            elif event == WindowEvent.RELEASE_REWIND_BACK:
                self.rewind_speed = 1
            elif event == WindowEvent.PRESS_REWIND_BACK:
                self.pyboy._pause()
                if self.rewind_buffer.seek_frame(-1):
                    self.mb.load_state(self.rewind_buffer)
                    events.append(WindowEvent._INTERNAL_RENDERER_FLUSH)
                    self.rewind_speed = min(self.rewind_speed * 1.1, 5)
                else:
                    logger.info(&#34;Rewind limit reached&#34;)

        if old_rewind_speed != self.rewind_speed:
            # NOTE: Disable this line, if recording for .replay files
            self.pyboy.set_emulation_speed(int(self.rewind_speed))
        return events

    def enabled(self):
        return self.pyboy_argv.get(&#39;rewind&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyboy.plugins.base_plugin.PyBoyPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyPlugin">PyBoyPlugin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyboy.plugins.rewind.Rewind.argv"><code class="name">var <span class="ident">argv</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyboy.plugins.rewind.Rewind.enabled"><code class="name flex">
<span>def <span class="ident">enabled</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def enabled(self):
    return self.pyboy_argv.get(&#39;rewind&#39;)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.Rewind.handle_events"><code class="name flex">
<span>def <span class="ident">handle_events</span></span>(<span>self, events)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_events(self, events):
    old_rewind_speed = self.rewind_speed
    for event in events:
        if event == WindowEvent.UNPAUSE:
            self.rewind_buffer.commit()
        elif event == WindowEvent.PAUSE_TOGGLE:
            if self.pyboy.paused:
                self.rewind_buffer.commit()
        elif event == WindowEvent.RELEASE_REWIND_FORWARD:
            self.rewind_speed = 1
        elif event == WindowEvent.PRESS_REWIND_FORWARD:
            self.pyboy._pause()
            if self.rewind_buffer.seek_frame(1):
                self.mb.load_state(self.rewind_buffer)
                events.append(WindowEvent._INTERNAL_RENDERER_FLUSH)
                self.rewind_speed = min(self.rewind_speed * 1.1, 5)
            else:
                logger.info(&#34;Rewind limit reached&#34;)
        elif event == WindowEvent.RELEASE_REWIND_BACK:
            self.rewind_speed = 1
        elif event == WindowEvent.PRESS_REWIND_BACK:
            self.pyboy._pause()
            if self.rewind_buffer.seek_frame(-1):
                self.mb.load_state(self.rewind_buffer)
                events.append(WindowEvent._INTERNAL_RENDERER_FLUSH)
                self.rewind_speed = min(self.rewind_speed * 1.1, 5)
            else:
                logger.info(&#34;Rewind limit reached&#34;)

    if old_rewind_speed != self.rewind_speed:
        # NOTE: Disable this line, if recording for .replay files
        self.pyboy.set_emulation_speed(int(self.rewind_speed))
    return events</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.Rewind.post_tick"><code class="name flex">
<span>def <span class="ident">post_tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def post_tick(self):
    if not self.pyboy.paused:
        self.mb.save_state(self.rewind_buffer)
        self.rewind_buffer.new()</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.rewind.Rewind.window_title"><code class="name flex">
<span>def <span class="ident">window_title</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def window_title(self):
    return &#34; Rewind: %0.2fKB/s&#34; % ((self.rewind_buffer.avg_section_size*60)/1024)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyboy.plugins" href="index.html">pyboy.plugins</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyboy.plugins.rewind.CompressedFixedAllocBuffers" href="#pyboy.plugins.rewind.CompressedFixedAllocBuffers">CompressedFixedAllocBuffers</a></code></h4>
<ul class="two-column">
<li><code><a title="pyboy.plugins.rewind.CompressedFixedAllocBuffers.commit" href="#pyboy.plugins.rewind.CompressedFixedAllocBuffers.commit">commit</a></code></li>
<li><code><a title="pyboy.plugins.rewind.CompressedFixedAllocBuffers.flush" href="#pyboy.plugins.rewind.CompressedFixedAllocBuffers.flush">flush</a></code></li>
<li><code><a title="pyboy.plugins.rewind.CompressedFixedAllocBuffers.new" href="#pyboy.plugins.rewind.CompressedFixedAllocBuffers.new">new</a></code></li>
<li><code><a title="pyboy.plugins.rewind.CompressedFixedAllocBuffers.read" href="#pyboy.plugins.rewind.CompressedFixedAllocBuffers.read">read</a></code></li>
<li><code><a title="pyboy.plugins.rewind.CompressedFixedAllocBuffers.seek_frame" href="#pyboy.plugins.rewind.CompressedFixedAllocBuffers.seek_frame">seek_frame</a></code></li>
<li><code><a title="pyboy.plugins.rewind.CompressedFixedAllocBuffers.write" href="#pyboy.plugins.rewind.CompressedFixedAllocBuffers.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.plugins.rewind.DeltaFixedAllocBuffers" href="#pyboy.plugins.rewind.DeltaFixedAllocBuffers">DeltaFixedAllocBuffers</a></code></h4>
<ul class="">
<li><code><a title="pyboy.plugins.rewind.DeltaFixedAllocBuffers.commit" href="#pyboy.plugins.rewind.DeltaFixedAllocBuffers.commit">commit</a></code></li>
<li><code><a title="pyboy.plugins.rewind.DeltaFixedAllocBuffers.flush_internal_buffer" href="#pyboy.plugins.rewind.DeltaFixedAllocBuffers.flush_internal_buffer">flush_internal_buffer</a></code></li>
<li><code><a title="pyboy.plugins.rewind.DeltaFixedAllocBuffers.new" href="#pyboy.plugins.rewind.DeltaFixedAllocBuffers.new">new</a></code></li>
<li><code><a title="pyboy.plugins.rewind.DeltaFixedAllocBuffers.read" href="#pyboy.plugins.rewind.DeltaFixedAllocBuffers.read">read</a></code></li>
<li><code><a title="pyboy.plugins.rewind.DeltaFixedAllocBuffers.seek_frame" href="#pyboy.plugins.rewind.DeltaFixedAllocBuffers.seek_frame">seek_frame</a></code></li>
<li><code><a title="pyboy.plugins.rewind.DeltaFixedAllocBuffers.write" href="#pyboy.plugins.rewind.DeltaFixedAllocBuffers.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.plugins.rewind.FixedAllocBuffers" href="#pyboy.plugins.rewind.FixedAllocBuffers">FixedAllocBuffers</a></code></h4>
<ul class="two-column">
<li><code><a title="pyboy.plugins.rewind.FixedAllocBuffers.commit" href="#pyboy.plugins.rewind.FixedAllocBuffers.commit">commit</a></code></li>
<li><code><a title="pyboy.plugins.rewind.FixedAllocBuffers.flush" href="#pyboy.plugins.rewind.FixedAllocBuffers.flush">flush</a></code></li>
<li><code><a title="pyboy.plugins.rewind.FixedAllocBuffers.new" href="#pyboy.plugins.rewind.FixedAllocBuffers.new">new</a></code></li>
<li><code><a title="pyboy.plugins.rewind.FixedAllocBuffers.read" href="#pyboy.plugins.rewind.FixedAllocBuffers.read">read</a></code></li>
<li><code><a title="pyboy.plugins.rewind.FixedAllocBuffers.seek_frame" href="#pyboy.plugins.rewind.FixedAllocBuffers.seek_frame">seek_frame</a></code></li>
<li><code><a title="pyboy.plugins.rewind.FixedAllocBuffers.stop" href="#pyboy.plugins.rewind.FixedAllocBuffers.stop">stop</a></code></li>
<li><code><a title="pyboy.plugins.rewind.FixedAllocBuffers.write" href="#pyboy.plugins.rewind.FixedAllocBuffers.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.plugins.rewind.Rewind" href="#pyboy.plugins.rewind.Rewind">Rewind</a></code></h4>
<ul class="">
<li><code><a title="pyboy.plugins.rewind.Rewind.argv" href="#pyboy.plugins.rewind.Rewind.argv">argv</a></code></li>
<li><code><a title="pyboy.plugins.rewind.Rewind.enabled" href="#pyboy.plugins.rewind.Rewind.enabled">enabled</a></code></li>
<li><code><a title="pyboy.plugins.rewind.Rewind.handle_events" href="#pyboy.plugins.rewind.Rewind.handle_events">handle_events</a></code></li>
<li><code><a title="pyboy.plugins.rewind.Rewind.post_tick" href="#pyboy.plugins.rewind.Rewind.post_tick">post_tick</a></code></li>
<li><code><a title="pyboy.plugins.rewind.Rewind.window_title" href="#pyboy.plugins.rewind.Rewind.window_title">window_title</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>