<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>pyboy.plugins.debug API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyboy.plugins.debug</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#
# License: See LICENSE file
# GitHub: https://github.com/Baekalfen/PyBoy
#

import ctypes
import logging
from array import array

import sdl2
from pyboy.botsupport import constants, tilemap  # , tile
from pyboy.botsupport.sprite import Sprite
from pyboy.plugins.base_plugin import PyBoyWindowPlugin
from pyboy.plugins.window_sdl2 import sdl2_event_pump
from pyboy.utils import WindowEvent

logger = logging.getLogger(__name__)

try:
    from cython import compiled
    cythonmode = compiled
except ImportError:
    cythonmode = False

# Mask colors:
COLOR = 0x00000000
# MASK = 0x00C0C000
COLOR_BACKGROUND = 0x00C0C000
COLOR_WINDOW = 0xC179D400

# Additive colors
HOVER = 0xFF0000
mark_counter = 0
# By using a set, we avoid duplicates
marked_tiles = set([])
MARK = array(&#39;I&#39;, [0xFF000000, 0xFFC00000, 0xFFFC0000, 0x00FFFF00, 0xFF00FF00])

SPRITE_BACKGROUND = COLOR_BACKGROUND


class MarkedTile:
    def __init__(self, event=WindowEvent._INTERNAL_MARK_TILE, tile_identifier=-1, mark_id=&#34;&#34;, mark_color=0,
            sprite_height=8, sprite=False):
        self.tile_identifier = tile_identifier
        self.mark_id = mark_id
        self.mark_color = mark_color
        self.sprite_height = sprite_height
        if mark_id == &#34;TILE&#34;:
            # TODO: Use __str__ of the Tile and Sprite classes
            logger.info(f&#34;Marked Tile - identifier: {tile_identifier}&#34;)
        elif mark_id == &#34;SPRITE&#34;:
            logger.info(f&#34;Marked Sprite - tile identifier: {tile_identifier}, sprite height: {sprite_height}&#34;)
        else:
            logger.info(f&#34;Marked {mark_id} - tile identifier: {tile_identifier}&#34;)

    def __hash__(self):
        return hash(self.tile_identifier)


class Debug(PyBoyWindowPlugin):
    argv = [(&#39;-d&#39;, &#39;--debug&#39;, {&#34;action&#34;: &#39;store_true&#39;, &#34;help&#34;: &#39;Enable emulator debugging mode&#39;})]

    def __init__(self, pyboy, mb, pyboy_argv):
        super().__init__(pyboy, mb, pyboy_argv)

        if not self.enabled():
            return


        self.sdl2_event_pump = self.pyboy_argv.get(&#39;window_type&#39;) != &#39;SDL2&#39;
        if self.sdl2_event_pump:
            sdl2.SDL_Init(sdl2.SDL_INIT_VIDEO)

        # self.scale = 2
        window_pos = 0

        self.tile1 = TileViewWindow(pyboy, mb, pyboy_argv, scale=2, title=&#34;Background&#34;, width=256, height=256, pos_x=0,
                pos_y=0, window_map=False, scanline_x=0, scanline_y=1)
        window_pos += (256*self.tile1.scale)

        self.tile2 = TileViewWindow(pyboy, mb, pyboy_argv, scale=2, title=&#34;Window&#34;, width=256, height=256,
                pos_x=window_pos, pos_y=0, window_map=True, scanline_x=2, scanline_y=3)
        window_pos += (256*self.tile2.scale)

        self.spriteview = SpriteViewWindow(pyboy, mb, pyboy_argv, scale=2, title=&#34;Sprite View&#34;, width=constants.COLS,
                height=constants.ROWS, pos_x=window_pos, pos_y=0)

        self.sprite = SpriteWindow(pyboy, mb, pyboy_argv, scale=3, title=&#34;Sprite Data&#34;, width=8*10, height=16*4,
                pos_x=window_pos, pos_y=self.spriteview.height*2+68)
        window_pos += (constants.COLS*self.spriteview.scale)

        tile_data_width = 16*8 # Change the 16 to however wide you want the tile window
        tile_data_height = ((constants.TILES*8) // tile_data_width)*8
        self.tiledata = TileDataWindow(pyboy, mb, pyboy_argv, scale=3, title=&#34;Tile Data&#34;, width=tile_data_width,
                height=tile_data_height, pos_x=window_pos, pos_y=0)


    def post_tick(self):
        self.tile1.post_tick()
        self.tile2.post_tick()
        self.tiledata.post_tick()
        self.sprite.post_tick()
        self.spriteview.post_tick()

    def handle_events(self, events):
        if self.sdl2_event_pump:
            events = sdl2_event_pump(events)
        events = self.tile1.handle_events(events)
        events = self.tile2.handle_events(events)
        events = self.tiledata.handle_events(events)
        events = self.sprite.handle_events(events)
        events = self.spriteview.handle_events(events)
        return events

    def stop(self):
        if self.sdl2_event_pump:
            sdl2.SDL_Quit()

    def enabled(self):
        return self.pyboy_argv.get(&#39;debug&#39;)


def make_buffer(w, h):
    buf = array(&#39;B&#39;, [0x55] * (w*h*4))
    if cythonmode:
        buf0 = memoryview(buf).cast(&#39;I&#39;, shape=(h, w))
        buf_p = None
    else:
        view = memoryview(buf).cast(&#39;I&#39;)
        buf0 = [view[i:i+w] for i in range(0, w*h, w)]
        buf_p = ctypes.c_void_p(buf.buffer_info()[0])
    return buf, buf0, buf_p


class BaseDebugWindow(PyBoyWindowPlugin):
    def __init__(self, pyboy, mb, pyboy_argv, *, scale, title, width, height, pos_x, pos_y):
        super().__init__(pyboy, mb, pyboy_argv)
        self.scale = scale
        self.width, self.height = width, height
        self.base_title = title
        self.hover_x = -1
        self.hover_y = -1

        self._window = sdl2.SDL_CreateWindow(
            self.base_title.encode(&#39;utf8&#39;),
            pos_x,
            pos_y,
            width*scale,
            height*scale,
            sdl2.SDL_WINDOW_RESIZABLE)
        self.window_id = sdl2.SDL_GetWindowID(self._window)

        self.buf, self.buf0, self.buf_p = make_buffer(width, height)

        self._sdlrenderer = sdl2.SDL_CreateRenderer(self._window, -1, sdl2.SDL_RENDERER_ACCELERATED)
        self._sdltexturebuffer = sdl2.SDL_CreateTexture(
            self._sdlrenderer,
            sdl2.SDL_PIXELFORMAT_RGBA8888,
            sdl2.SDL_TEXTUREACCESS_STATIC,
            width,
            height
        )

    def handle_events(self, events):
        # Feed events into the loop
        for event in events:
            if event == WindowEvent._INTERNAL_MOUSE:
                if event.window_id == self.window_id:
                    self.hover_x = event.mouse_x // self.scale
                    self.hover_y = event.mouse_y // self.scale
                else:
                    self.hover_x = -1
                    self.hover_y = -1

        return events

    def stop(self):
        sdl2.SDL_DestroyWindow(self._window)

    def update_title(self):
        pass

    def post_tick(self):
        self.update_title()
        self._update_display()

    ##########################
    # Internal functions
    def copy_tile(self, tile_cache0, t, xx, yy, to_buffer):
        for y in range(8):
            for x in range(8):
                to_buffer[yy+y][xx+x] = tile_cache0[y + t*8][x]

    def mark_tile(self, x, y, color, height, width, grid):
        tw = width # Tile width
        th = height # Tile height
        if grid:
            xx = x - (x % tw)
            yy = y - (y % th)
        else:
            xx = x
            yy = y
        for i in range(th):
            if 0 &lt;= (yy+i) &lt; self.height and 0 &lt;= xx &lt; self.width:
                self.buf0[yy+i][xx] = color
        for i in range(tw):
            if 0 &lt;= (yy) &lt; self.height and 0 &lt;= xx+i &lt; self.width:
                self.buf0[yy][xx+i] = color
        for i in range(tw):
            if 0 &lt;= (yy+th-1) &lt; self.height and 0 &lt;= xx+i &lt; self.width:
                self.buf0[yy+th-1][xx+i] = color
        for i in range(th):
            if 0 &lt;= (yy+i) &lt; self.height and 0 &lt;= xx+tw-1 &lt; self.width:
                self.buf0[yy+i][xx+tw-1] = color


class TileViewWindow(BaseDebugWindow):
    def __init__(self, *args, window_map, scanline_x, scanline_y, **kwargs):
        super().__init__(*args, **kwargs)
        self.scanline_x, self.scanline_y = scanline_x, scanline_y
        self.color = COLOR_WINDOW if window_map else COLOR_BACKGROUND

        if not cythonmode:
            self.tilemap = tilemap.TileMap(self.mb, &#34;WINDOW&#34; if window_map else &#34;BACKGROUND&#34;)

    def __cinit__(self, pyboy, mb, *args, window_map, **kwargs):
        self.tilemap = tilemap.TileMap(self.mb, &#34;WINDOW&#34; if window_map else &#34;BACKGROUND&#34;)

    def post_tick(self):
        tile_cache0 = self.renderer._tilecache

        # Updating screen buffer by copying tiles from cache
        mem_offset = self.tilemap.map_offset - constants.VRAM_OFFSET
        for n in range(mem_offset, mem_offset + 0x400):
            tile_index = self.mb.lcd.VRAM[n]

            # Check the tile source and add offset
            # http://problemkaputt.de/pandocs.htm#lcdcontrolregister
            # BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
            if self.mb.lcd.LCDC.tiledata_select == 0:
                # (x ^ 0x80 - 128) to convert to signed, then add 256 for offset (reduces to + 128)
                tile_index = (tile_index ^ 0x80) + 128

            tile_column = (n-mem_offset) % 32
            tile_row = (n-mem_offset) // 32

            self.copy_tile(tile_cache0, tile_index, tile_column * 8, tile_row * 8, self.buf0)

        self.draw_overlay()
        BaseDebugWindow.post_tick(self)

    def handle_events(self, events):
        global mark_counter, marked_tiles

        self.tilemap.refresh_lcdc()

        # Feed events into the loop
        events = BaseDebugWindow.handle_events(self, events)
        for event in events:
            if event == WindowEvent._INTERNAL_MOUSE and event.window_id == self.window_id:
                if event.mouse_button == 0:
                    tile_x, tile_y = event.mouse_x // self.scale // 8, event.mouse_y // self.scale // 8
                    tile_identifier = self.tilemap.tile_identifier(tile_x, tile_y)
                    logger.info(f&#34;Tile clicked on {tile_x}, {tile_y}&#34;)
                    marked_tiles.add(
                        MarkedTile(
                            tile_identifier=tile_identifier,
                            mark_id=&#34;TILE&#34;,
                            mark_color=MARK[mark_counter]
                        )
                    )
                    mark_counter += 1
                    mark_counter %= len(MARK)
                elif event.mouse_button == 1:
                    marked_tiles.clear()
            elif event == WindowEvent._INTERNAL_MARK_TILE:
                marked_tiles.add(event.tile_identifier)

        return events

    def update_title(self):
        title = self.base_title
        title += &#34; [HIGH MAP 0x9C00-0x9FFF]&#34; if self.tilemap.map_offset == constants.HIGH_TILEMAP else \
            &#34; [LOW MAP 0x9800-0x9BFF]&#34;
        title += &#34; [HIGH DATA (SIGNED) 0x8800-0x97FF]&#34; if self.tilemap.signed_tile_data else \
            &#34; [LOW DATA (UNSIGNED) 0x8000-0x8FFF]&#34;
        if self.tilemap._select == &#34;WINDOW&#34;:
            title += &#34; [Window]&#34;
        if self.tilemap._select == &#34;BACKGROUND&#34;:
            title += &#34; [Background]&#34;
        sdl2.SDL_SetWindowTitle(self._window, title.encode(&#39;utf8&#39;))

    def draw_overlay(self):
        global marked_tiles
        scanlineparameters = self.pyboy.screen().tilemap_position_list()

        # Mark screen area
        for y in range(constants.ROWS):
            xx = int(scanlineparameters[y][self.scanline_x])
            yy = int(scanlineparameters[y][self.scanline_y])
            if y == 0 or y == constants.ROWS-1:
                for x in range(constants.COLS):
                    self.buf0[(yy+y) % 0xFF][(xx+x) % 0xFF] = COLOR
            else:
                self.buf0[(yy+y) % 0xFF][xx % 0xFF] = COLOR
                for x in range(constants.COLS):
                    self.buf0[(yy+y) % 0xFF][(xx+x) % 0xFF] &amp;= self.color
                self.buf0[(yy+y) % 0xFF][(xx+constants.COLS) % 0xFF] = COLOR

        # Mark selected tiles
        for t, match in zip(
            marked_tiles,
            self.tilemap.search_for_identifiers([m.tile_identifier for m in marked_tiles])
        ):
            for row, column in match:
                self.mark_tile(column * 8, row * 8, t.mark_color, 8, 8, True)
        if self.hover_x != -1:
            self.mark_tile(self.hover_x, self.hover_y, HOVER, 8, 8, True)


class TileDataWindow(BaseDebugWindow):
    def post_tick(self):
        tile_cache0 = self.renderer._tilecache

        for t in range(constants.TILES):
            xx = (t * 8) % self.width
            yy = ((t * 8) // self.width)*8
            self.copy_tile(tile_cache0, t, xx, yy, self.buf0)

        self.draw_overlay()
        BaseDebugWindow.post_tick(self)

    def handle_events(self, events):
        global mark_counter, marked_tiles
        # Feed events into the loop
        events = BaseDebugWindow.handle_events(self, events)
        for event in events:
            if event == WindowEvent._INTERNAL_MOUSE and event.window_id == self.window_id:
                if event.mouse_button == 0:
                    tile_x, tile_y = event.mouse_x // self.scale // 8, event.mouse_y // self.scale // 8
                    tile_identifier = tile_y * (self.width//8) + tile_x
                    marked_tiles.add(
                        MarkedTile(
                            tile_identifier=tile_identifier,
                            mark_id=&#34;TILE&#34;,
                            mark_color=MARK[mark_counter]
                        )
                    )
                    mark_counter += 1
                    mark_counter %= len(MARK)
                elif event.mouse_button == 1:
                    marked_tiles.clear()
            elif event == WindowEvent._INTERNAL_MARK_TILE:
                marked_tiles.add(event.tile_identifier)
        return events

    def draw_overlay(self):
        # Mark selected tiles
        for t in marked_tiles:
            column = t.tile_identifier % (self.width//8)
            row = t.tile_identifier // (self.width//8)
            # Yes, we are using the height as width. This is because we present the tile data from left to right,
            # but the sprites with a height of 16, renders them stacked ontop of each other.
            self.mark_tile(column*8, row*8, t.mark_color, t.sprite_height, 8, True)



class SpriteWindow(BaseDebugWindow):
    def post_tick(self):
        tile_cache0 = self.renderer._tilecache

        sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
        for n in range(0, 0xA0, 4):
            # x = lcd.OAM[n]
            # y = lcd.OAM[n+1]
            t = self.mb.lcd.OAM[n+2]
            # attributes = lcd.OAM[n+3]
            xx = ((n//4) * 8) % self.width
            yy = (((n//4) * 8) // self.width)*sprite_height
            self.copy_tile(tile_cache0, t, xx, yy, self.buf0)
            if sprite_height:
                self.copy_tile(tile_cache0, t+1, xx, yy+8, self.buf0)

        self.draw_overlay()
        BaseDebugWindow.post_tick(self)

    def handle_events(self, events):
        global mark_counter, marked_tiles

        # Feed events into the loop
        events = BaseDebugWindow.handle_events(self, events)

        sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
        for event in events:
            if event == WindowEvent._INTERNAL_MOUSE and event.window_id == self.window_id:
                if event.mouse_button == 0:
                    tile_x, tile_y = event.mouse_x // self.scale // 8, event.mouse_y // self.scale // sprite_height
                    sprite_identifier = tile_y * (self.width//8) + tile_x
                    sprite = Sprite(self.mb, sprite_identifier)
                    marked_tiles.add(
                        MarkedTile(
                            tile_identifier=sprite.tile_identifier,
                            mark_id=&#34;SPRITE&#34;,
                            mark_color=MARK[mark_counter],
                            sprite_height=sprite_height,
                            sprite=True,
                        )
                    )
                    mark_counter += 1
                    mark_counter %= len(MARK)
                elif event.mouse_button == 1:
                    marked_tiles.clear()
            elif event == WindowEvent._INTERNAL_MARK_TILE:
                marked_tiles.add(event.tile_identifier)
        return events

    def draw_overlay(self):
        sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
        # Mark selected tiles
        for m, matched_sprites in zip(marked_tiles, self.pyboy.sprite_by_tile_identifier([m.tile_identifier for m in marked_tiles])):
            for sprite_index in matched_sprites:
                xx = (sprite_index * 8) % self.width
                yy = ((sprite_index * 8) // self.width)*sprite_height
                self.mark_tile(xx, yy, m.mark_color, sprite_height, 8, True)

        if self.hover_x != -1:
            self.mark_tile(self.hover_x, self.hover_y, HOVER, sprite_height, 8, True)

    def update_title(self):
        title = self.base_title
        title += &#34; [8x16]&#34; if self.mb.lcd.LCDC.sprite_height else &#34; [8x8]&#34;
        sdl2.SDL_SetWindowTitle(self._window, title.encode(&#39;utf8&#39;))


class SpriteViewWindow(BaseDebugWindow):
    def post_tick(self):
        for y in range(constants.ROWS):
            for x in range(constants.COLS):
                self.buf0[y][x] = SPRITE_BACKGROUND

        self.mb.renderer.render_sprites(self.mb.lcd, self.buf0)
        self.draw_overlay()
        BaseDebugWindow.post_tick(self)

    def draw_overlay(self):
        sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
        # Mark selected tiles
        for m, matched_sprites in zip(marked_tiles, self.pyboy.sprite_by_tile_identifier([m.tile_identifier for m in marked_tiles])):
            for sprite_index in matched_sprites:
                sprite = Sprite(self.mb, sprite_index)
                self.mark_tile(sprite.x, sprite.y, m.mark_color, sprite_height, 8, False)

    def update_title(self):
        title = self.base_title
        title += &#34; &#34; if self.mb.lcd.LCDC.sprite_enable else &#34; [Disabled]&#34;
        sdl2.SDL_SetWindowTitle(self._window, title.encode(&#39;utf8&#39;))


# Unfortunately CPython/PyPy code has to be hidden in an exec call to
# prevent Cython from trying to parse it. This block provides the
# functions that are otherwise implemented as inlined cdefs in the pxd
if not cythonmode:
    exec(&#34;&#34;&#34;
def _update_display(self):
    sdl2.SDL_UpdateTexture(self._sdltexturebuffer, None, self.buf_p, self.width*4)
    sdl2.SDL_RenderCopy(self._sdlrenderer, self._sdltexturebuffer, None, None)
    sdl2.SDL_RenderPresent(self._sdlrenderer)
    sdl2.SDL_RenderClear(self._sdlrenderer)

BaseDebugWindow._update_display = _update_display
&#34;&#34;&#34;, globals(), locals())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyboy.plugins.debug.make_buffer"><code class="name flex">
<span>def <span class="ident">make_buffer</span></span>(<span>w, h)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_buffer(w, h):
    buf = array(&#39;B&#39;, [0x55] * (w*h*4))
    if cythonmode:
        buf0 = memoryview(buf).cast(&#39;I&#39;, shape=(h, w))
        buf_p = None
    else:
        view = memoryview(buf).cast(&#39;I&#39;)
        buf0 = [view[i:i+w] for i in range(0, w*h, w)]
        buf_p = ctypes.c_void_p(buf.buffer_info()[0])
    return buf, buf0, buf_p</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyboy.plugins.debug.BaseDebugWindow"><code class="flex name class">
<span>class <span class="ident">BaseDebugWindow</span></span>
<span>(</span><span>pyboy, mb, pyboy_argv, *, scale, title, width, height, pos_x, pos_y)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class BaseDebugWindow(PyBoyWindowPlugin):
    def __init__(self, pyboy, mb, pyboy_argv, *, scale, title, width, height, pos_x, pos_y):
        super().__init__(pyboy, mb, pyboy_argv)
        self.scale = scale
        self.width, self.height = width, height
        self.base_title = title
        self.hover_x = -1
        self.hover_y = -1

        self._window = sdl2.SDL_CreateWindow(
            self.base_title.encode(&#39;utf8&#39;),
            pos_x,
            pos_y,
            width*scale,
            height*scale,
            sdl2.SDL_WINDOW_RESIZABLE)
        self.window_id = sdl2.SDL_GetWindowID(self._window)

        self.buf, self.buf0, self.buf_p = make_buffer(width, height)

        self._sdlrenderer = sdl2.SDL_CreateRenderer(self._window, -1, sdl2.SDL_RENDERER_ACCELERATED)
        self._sdltexturebuffer = sdl2.SDL_CreateTexture(
            self._sdlrenderer,
            sdl2.SDL_PIXELFORMAT_RGBA8888,
            sdl2.SDL_TEXTUREACCESS_STATIC,
            width,
            height
        )

    def handle_events(self, events):
        # Feed events into the loop
        for event in events:
            if event == WindowEvent._INTERNAL_MOUSE:
                if event.window_id == self.window_id:
                    self.hover_x = event.mouse_x // self.scale
                    self.hover_y = event.mouse_y // self.scale
                else:
                    self.hover_x = -1
                    self.hover_y = -1

        return events

    def stop(self):
        sdl2.SDL_DestroyWindow(self._window)

    def update_title(self):
        pass

    def post_tick(self):
        self.update_title()
        self._update_display()

    ##########################
    # Internal functions
    def copy_tile(self, tile_cache0, t, xx, yy, to_buffer):
        for y in range(8):
            for x in range(8):
                to_buffer[yy+y][xx+x] = tile_cache0[y + t*8][x]

    def mark_tile(self, x, y, color, height, width, grid):
        tw = width # Tile width
        th = height # Tile height
        if grid:
            xx = x - (x % tw)
            yy = y - (y % th)
        else:
            xx = x
            yy = y
        for i in range(th):
            if 0 &lt;= (yy+i) &lt; self.height and 0 &lt;= xx &lt; self.width:
                self.buf0[yy+i][xx] = color
        for i in range(tw):
            if 0 &lt;= (yy) &lt; self.height and 0 &lt;= xx+i &lt; self.width:
                self.buf0[yy][xx+i] = color
        for i in range(tw):
            if 0 &lt;= (yy+th-1) &lt; self.height and 0 &lt;= xx+i &lt; self.width:
                self.buf0[yy+th-1][xx+i] = color
        for i in range(th):
            if 0 &lt;= (yy+i) &lt; self.height and 0 &lt;= xx+tw-1 &lt; self.width:
                self.buf0[yy+i][xx+tw-1] = color</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyboy.plugins.base_plugin.PyBoyWindowPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyWindowPlugin">PyBoyWindowPlugin</a></li>
<li><a title="pyboy.plugins.base_plugin.PyBoyPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyPlugin">PyBoyPlugin</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyboy.plugins.debug.TileViewWindow</li>
<li>pyboy.plugins.debug.TileDataWindow</li>
<li>pyboy.plugins.debug.SpriteWindow</li>
<li>pyboy.plugins.debug.SpriteViewWindow</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyboy.plugins.debug.BaseDebugWindow.copy_tile"><code class="name flex">
<span>def <span class="ident">copy_tile</span></span>(<span>self, tile_cache0, t, xx, yy, to_buffer)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def copy_tile(self, tile_cache0, t, xx, yy, to_buffer):
    for y in range(8):
        for x in range(8):
            to_buffer[yy+y][xx+x] = tile_cache0[y + t*8][x]</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.BaseDebugWindow.handle_events"><code class="name flex">
<span>def <span class="ident">handle_events</span></span>(<span>self, events)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_events(self, events):
    # Feed events into the loop
    for event in events:
        if event == WindowEvent._INTERNAL_MOUSE:
            if event.window_id == self.window_id:
                self.hover_x = event.mouse_x // self.scale
                self.hover_y = event.mouse_y // self.scale
            else:
                self.hover_x = -1
                self.hover_y = -1

    return events</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.BaseDebugWindow.mark_tile"><code class="name flex">
<span>def <span class="ident">mark_tile</span></span>(<span>self, x, y, color, height, width, grid)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def mark_tile(self, x, y, color, height, width, grid):
    tw = width # Tile width
    th = height # Tile height
    if grid:
        xx = x - (x % tw)
        yy = y - (y % th)
    else:
        xx = x
        yy = y
    for i in range(th):
        if 0 &lt;= (yy+i) &lt; self.height and 0 &lt;= xx &lt; self.width:
            self.buf0[yy+i][xx] = color
    for i in range(tw):
        if 0 &lt;= (yy) &lt; self.height and 0 &lt;= xx+i &lt; self.width:
            self.buf0[yy][xx+i] = color
    for i in range(tw):
        if 0 &lt;= (yy+th-1) &lt; self.height and 0 &lt;= xx+i &lt; self.width:
            self.buf0[yy+th-1][xx+i] = color
    for i in range(th):
        if 0 &lt;= (yy+i) &lt; self.height and 0 &lt;= xx+tw-1 &lt; self.width:
            self.buf0[yy+i][xx+tw-1] = color</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.BaseDebugWindow.post_tick"><code class="name flex">
<span>def <span class="ident">post_tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def post_tick(self):
    self.update_title()
    self._update_display()</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.BaseDebugWindow.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def stop(self):
    sdl2.SDL_DestroyWindow(self._window)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.BaseDebugWindow.update_title"><code class="name flex">
<span>def <span class="ident">update_title</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update_title(self):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.plugins.debug.Debug"><code class="flex name class">
<span>class <span class="ident">Debug</span></span>
<span>(</span><span>pyboy, mb, pyboy_argv)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Debug(PyBoyWindowPlugin):
    argv = [(&#39;-d&#39;, &#39;--debug&#39;, {&#34;action&#34;: &#39;store_true&#39;, &#34;help&#34;: &#39;Enable emulator debugging mode&#39;})]

    def __init__(self, pyboy, mb, pyboy_argv):
        super().__init__(pyboy, mb, pyboy_argv)

        if not self.enabled():
            return


        self.sdl2_event_pump = self.pyboy_argv.get(&#39;window_type&#39;) != &#39;SDL2&#39;
        if self.sdl2_event_pump:
            sdl2.SDL_Init(sdl2.SDL_INIT_VIDEO)

        # self.scale = 2
        window_pos = 0

        self.tile1 = TileViewWindow(pyboy, mb, pyboy_argv, scale=2, title=&#34;Background&#34;, width=256, height=256, pos_x=0,
                pos_y=0, window_map=False, scanline_x=0, scanline_y=1)
        window_pos += (256*self.tile1.scale)

        self.tile2 = TileViewWindow(pyboy, mb, pyboy_argv, scale=2, title=&#34;Window&#34;, width=256, height=256,
                pos_x=window_pos, pos_y=0, window_map=True, scanline_x=2, scanline_y=3)
        window_pos += (256*self.tile2.scale)

        self.spriteview = SpriteViewWindow(pyboy, mb, pyboy_argv, scale=2, title=&#34;Sprite View&#34;, width=constants.COLS,
                height=constants.ROWS, pos_x=window_pos, pos_y=0)

        self.sprite = SpriteWindow(pyboy, mb, pyboy_argv, scale=3, title=&#34;Sprite Data&#34;, width=8*10, height=16*4,
                pos_x=window_pos, pos_y=self.spriteview.height*2+68)
        window_pos += (constants.COLS*self.spriteview.scale)

        tile_data_width = 16*8 # Change the 16 to however wide you want the tile window
        tile_data_height = ((constants.TILES*8) // tile_data_width)*8
        self.tiledata = TileDataWindow(pyboy, mb, pyboy_argv, scale=3, title=&#34;Tile Data&#34;, width=tile_data_width,
                height=tile_data_height, pos_x=window_pos, pos_y=0)


    def post_tick(self):
        self.tile1.post_tick()
        self.tile2.post_tick()
        self.tiledata.post_tick()
        self.sprite.post_tick()
        self.spriteview.post_tick()

    def handle_events(self, events):
        if self.sdl2_event_pump:
            events = sdl2_event_pump(events)
        events = self.tile1.handle_events(events)
        events = self.tile2.handle_events(events)
        events = self.tiledata.handle_events(events)
        events = self.sprite.handle_events(events)
        events = self.spriteview.handle_events(events)
        return events

    def stop(self):
        if self.sdl2_event_pump:
            sdl2.SDL_Quit()

    def enabled(self):
        return self.pyboy_argv.get(&#39;debug&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyboy.plugins.base_plugin.PyBoyWindowPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyWindowPlugin">PyBoyWindowPlugin</a></li>
<li><a title="pyboy.plugins.base_plugin.PyBoyPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyPlugin">PyBoyPlugin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyboy.plugins.debug.Debug.argv"><code class="name">var <span class="ident">argv</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyboy.plugins.debug.Debug.enabled"><code class="name flex">
<span>def <span class="ident">enabled</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def enabled(self):
    return self.pyboy_argv.get(&#39;debug&#39;)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.Debug.handle_events"><code class="name flex">
<span>def <span class="ident">handle_events</span></span>(<span>self, events)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_events(self, events):
    if self.sdl2_event_pump:
        events = sdl2_event_pump(events)
    events = self.tile1.handle_events(events)
    events = self.tile2.handle_events(events)
    events = self.tiledata.handle_events(events)
    events = self.sprite.handle_events(events)
    events = self.spriteview.handle_events(events)
    return events</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.Debug.post_tick"><code class="name flex">
<span>def <span class="ident">post_tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def post_tick(self):
    self.tile1.post_tick()
    self.tile2.post_tick()
    self.tiledata.post_tick()
    self.sprite.post_tick()
    self.spriteview.post_tick()</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.Debug.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def stop(self):
    if self.sdl2_event_pump:
        sdl2.SDL_Quit()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.plugins.debug.MarkedTile"><code class="flex name class">
<span>class <span class="ident">MarkedTile</span></span>
<span>(</span><span>event=35, tile_identifier=-1, mark_id='', mark_color=0, sprite_height=8, sprite=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class MarkedTile:
    def __init__(self, event=WindowEvent._INTERNAL_MARK_TILE, tile_identifier=-1, mark_id=&#34;&#34;, mark_color=0,
            sprite_height=8, sprite=False):
        self.tile_identifier = tile_identifier
        self.mark_id = mark_id
        self.mark_color = mark_color
        self.sprite_height = sprite_height
        if mark_id == &#34;TILE&#34;:
            # TODO: Use __str__ of the Tile and Sprite classes
            logger.info(f&#34;Marked Tile - identifier: {tile_identifier}&#34;)
        elif mark_id == &#34;SPRITE&#34;:
            logger.info(f&#34;Marked Sprite - tile identifier: {tile_identifier}, sprite height: {sprite_height}&#34;)
        else:
            logger.info(f&#34;Marked {mark_id} - tile identifier: {tile_identifier}&#34;)

    def __hash__(self):
        return hash(self.tile_identifier)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.SpriteViewWindow"><code class="flex name class">
<span>class <span class="ident">SpriteViewWindow</span></span>
<span>(</span><span>pyboy, mb, pyboy_argv, *, scale, title, width, height, pos_x, pos_y)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class SpriteViewWindow(BaseDebugWindow):
    def post_tick(self):
        for y in range(constants.ROWS):
            for x in range(constants.COLS):
                self.buf0[y][x] = SPRITE_BACKGROUND

        self.mb.renderer.render_sprites(self.mb.lcd, self.buf0)
        self.draw_overlay()
        BaseDebugWindow.post_tick(self)

    def draw_overlay(self):
        sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
        # Mark selected tiles
        for m, matched_sprites in zip(marked_tiles, self.pyboy.sprite_by_tile_identifier([m.tile_identifier for m in marked_tiles])):
            for sprite_index in matched_sprites:
                sprite = Sprite(self.mb, sprite_index)
                self.mark_tile(sprite.x, sprite.y, m.mark_color, sprite_height, 8, False)

    def update_title(self):
        title = self.base_title
        title += &#34; &#34; if self.mb.lcd.LCDC.sprite_enable else &#34; [Disabled]&#34;
        sdl2.SDL_SetWindowTitle(self._window, title.encode(&#39;utf8&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyboy.plugins.debug.BaseDebugWindow</li>
<li><a title="pyboy.plugins.base_plugin.PyBoyWindowPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyWindowPlugin">PyBoyWindowPlugin</a></li>
<li><a title="pyboy.plugins.base_plugin.PyBoyPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyPlugin">PyBoyPlugin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyboy.plugins.debug.SpriteViewWindow.draw_overlay"><code class="name flex">
<span>def <span class="ident">draw_overlay</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def draw_overlay(self):
    sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
    # Mark selected tiles
    for m, matched_sprites in zip(marked_tiles, self.pyboy.sprite_by_tile_identifier([m.tile_identifier for m in marked_tiles])):
        for sprite_index in matched_sprites:
            sprite = Sprite(self.mb, sprite_index)
            self.mark_tile(sprite.x, sprite.y, m.mark_color, sprite_height, 8, False)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.SpriteViewWindow.post_tick"><code class="name flex">
<span>def <span class="ident">post_tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def post_tick(self):
    for y in range(constants.ROWS):
        for x in range(constants.COLS):
            self.buf0[y][x] = SPRITE_BACKGROUND

    self.mb.renderer.render_sprites(self.mb.lcd, self.buf0)
    self.draw_overlay()
    BaseDebugWindow.post_tick(self)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.SpriteViewWindow.update_title"><code class="name flex">
<span>def <span class="ident">update_title</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update_title(self):
    title = self.base_title
    title += &#34; &#34; if self.mb.lcd.LCDC.sprite_enable else &#34; [Disabled]&#34;
    sdl2.SDL_SetWindowTitle(self._window, title.encode(&#39;utf8&#39;))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.plugins.debug.SpriteWindow"><code class="flex name class">
<span>class <span class="ident">SpriteWindow</span></span>
<span>(</span><span>pyboy, mb, pyboy_argv, *, scale, title, width, height, pos_x, pos_y)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class SpriteWindow(BaseDebugWindow):
    def post_tick(self):
        tile_cache0 = self.renderer._tilecache

        sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
        for n in range(0, 0xA0, 4):
            # x = lcd.OAM[n]
            # y = lcd.OAM[n+1]
            t = self.mb.lcd.OAM[n+2]
            # attributes = lcd.OAM[n+3]
            xx = ((n//4) * 8) % self.width
            yy = (((n//4) * 8) // self.width)*sprite_height
            self.copy_tile(tile_cache0, t, xx, yy, self.buf0)
            if sprite_height:
                self.copy_tile(tile_cache0, t+1, xx, yy+8, self.buf0)

        self.draw_overlay()
        BaseDebugWindow.post_tick(self)

    def handle_events(self, events):
        global mark_counter, marked_tiles

        # Feed events into the loop
        events = BaseDebugWindow.handle_events(self, events)

        sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
        for event in events:
            if event == WindowEvent._INTERNAL_MOUSE and event.window_id == self.window_id:
                if event.mouse_button == 0:
                    tile_x, tile_y = event.mouse_x // self.scale // 8, event.mouse_y // self.scale // sprite_height
                    sprite_identifier = tile_y * (self.width//8) + tile_x
                    sprite = Sprite(self.mb, sprite_identifier)
                    marked_tiles.add(
                        MarkedTile(
                            tile_identifier=sprite.tile_identifier,
                            mark_id=&#34;SPRITE&#34;,
                            mark_color=MARK[mark_counter],
                            sprite_height=sprite_height,
                            sprite=True,
                        )
                    )
                    mark_counter += 1
                    mark_counter %= len(MARK)
                elif event.mouse_button == 1:
                    marked_tiles.clear()
            elif event == WindowEvent._INTERNAL_MARK_TILE:
                marked_tiles.add(event.tile_identifier)
        return events

    def draw_overlay(self):
        sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
        # Mark selected tiles
        for m, matched_sprites in zip(marked_tiles, self.pyboy.sprite_by_tile_identifier([m.tile_identifier for m in marked_tiles])):
            for sprite_index in matched_sprites:
                xx = (sprite_index * 8) % self.width
                yy = ((sprite_index * 8) // self.width)*sprite_height
                self.mark_tile(xx, yy, m.mark_color, sprite_height, 8, True)

        if self.hover_x != -1:
            self.mark_tile(self.hover_x, self.hover_y, HOVER, sprite_height, 8, True)

    def update_title(self):
        title = self.base_title
        title += &#34; [8x16]&#34; if self.mb.lcd.LCDC.sprite_height else &#34; [8x8]&#34;
        sdl2.SDL_SetWindowTitle(self._window, title.encode(&#39;utf8&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyboy.plugins.debug.BaseDebugWindow</li>
<li><a title="pyboy.plugins.base_plugin.PyBoyWindowPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyWindowPlugin">PyBoyWindowPlugin</a></li>
<li><a title="pyboy.plugins.base_plugin.PyBoyPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyPlugin">PyBoyPlugin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyboy.plugins.debug.SpriteWindow.draw_overlay"><code class="name flex">
<span>def <span class="ident">draw_overlay</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def draw_overlay(self):
    sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
    # Mark selected tiles
    for m, matched_sprites in zip(marked_tiles, self.pyboy.sprite_by_tile_identifier([m.tile_identifier for m in marked_tiles])):
        for sprite_index in matched_sprites:
            xx = (sprite_index * 8) % self.width
            yy = ((sprite_index * 8) // self.width)*sprite_height
            self.mark_tile(xx, yy, m.mark_color, sprite_height, 8, True)

    if self.hover_x != -1:
        self.mark_tile(self.hover_x, self.hover_y, HOVER, sprite_height, 8, True)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.SpriteWindow.handle_events"><code class="name flex">
<span>def <span class="ident">handle_events</span></span>(<span>self, events)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_events(self, events):
    global mark_counter, marked_tiles

    # Feed events into the loop
    events = BaseDebugWindow.handle_events(self, events)

    sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
    for event in events:
        if event == WindowEvent._INTERNAL_MOUSE and event.window_id == self.window_id:
            if event.mouse_button == 0:
                tile_x, tile_y = event.mouse_x // self.scale // 8, event.mouse_y // self.scale // sprite_height
                sprite_identifier = tile_y * (self.width//8) + tile_x
                sprite = Sprite(self.mb, sprite_identifier)
                marked_tiles.add(
                    MarkedTile(
                        tile_identifier=sprite.tile_identifier,
                        mark_id=&#34;SPRITE&#34;,
                        mark_color=MARK[mark_counter],
                        sprite_height=sprite_height,
                        sprite=True,
                    )
                )
                mark_counter += 1
                mark_counter %= len(MARK)
            elif event.mouse_button == 1:
                marked_tiles.clear()
        elif event == WindowEvent._INTERNAL_MARK_TILE:
            marked_tiles.add(event.tile_identifier)
    return events</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.SpriteWindow.post_tick"><code class="name flex">
<span>def <span class="ident">post_tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def post_tick(self):
    tile_cache0 = self.renderer._tilecache

    sprite_height = 16 if self.mb.lcd.LCDC.sprite_height else 8
    for n in range(0, 0xA0, 4):
        # x = lcd.OAM[n]
        # y = lcd.OAM[n+1]
        t = self.mb.lcd.OAM[n+2]
        # attributes = lcd.OAM[n+3]
        xx = ((n//4) * 8) % self.width
        yy = (((n//4) * 8) // self.width)*sprite_height
        self.copy_tile(tile_cache0, t, xx, yy, self.buf0)
        if sprite_height:
            self.copy_tile(tile_cache0, t+1, xx, yy+8, self.buf0)

    self.draw_overlay()
    BaseDebugWindow.post_tick(self)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.SpriteWindow.update_title"><code class="name flex">
<span>def <span class="ident">update_title</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update_title(self):
    title = self.base_title
    title += &#34; [8x16]&#34; if self.mb.lcd.LCDC.sprite_height else &#34; [8x8]&#34;
    sdl2.SDL_SetWindowTitle(self._window, title.encode(&#39;utf8&#39;))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.plugins.debug.TileDataWindow"><code class="flex name class">
<span>class <span class="ident">TileDataWindow</span></span>
<span>(</span><span>pyboy, mb, pyboy_argv, *, scale, title, width, height, pos_x, pos_y)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TileDataWindow(BaseDebugWindow):
    def post_tick(self):
        tile_cache0 = self.renderer._tilecache

        for t in range(constants.TILES):
            xx = (t * 8) % self.width
            yy = ((t * 8) // self.width)*8
            self.copy_tile(tile_cache0, t, xx, yy, self.buf0)

        self.draw_overlay()
        BaseDebugWindow.post_tick(self)

    def handle_events(self, events):
        global mark_counter, marked_tiles
        # Feed events into the loop
        events = BaseDebugWindow.handle_events(self, events)
        for event in events:
            if event == WindowEvent._INTERNAL_MOUSE and event.window_id == self.window_id:
                if event.mouse_button == 0:
                    tile_x, tile_y = event.mouse_x // self.scale // 8, event.mouse_y // self.scale // 8
                    tile_identifier = tile_y * (self.width//8) + tile_x
                    marked_tiles.add(
                        MarkedTile(
                            tile_identifier=tile_identifier,
                            mark_id=&#34;TILE&#34;,
                            mark_color=MARK[mark_counter]
                        )
                    )
                    mark_counter += 1
                    mark_counter %= len(MARK)
                elif event.mouse_button == 1:
                    marked_tiles.clear()
            elif event == WindowEvent._INTERNAL_MARK_TILE:
                marked_tiles.add(event.tile_identifier)
        return events

    def draw_overlay(self):
        # Mark selected tiles
        for t in marked_tiles:
            column = t.tile_identifier % (self.width//8)
            row = t.tile_identifier // (self.width//8)
            # Yes, we are using the height as width. This is because we present the tile data from left to right,
            # but the sprites with a height of 16, renders them stacked ontop of each other.
            self.mark_tile(column*8, row*8, t.mark_color, t.sprite_height, 8, True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyboy.plugins.debug.BaseDebugWindow</li>
<li><a title="pyboy.plugins.base_plugin.PyBoyWindowPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyWindowPlugin">PyBoyWindowPlugin</a></li>
<li><a title="pyboy.plugins.base_plugin.PyBoyPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyPlugin">PyBoyPlugin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyboy.plugins.debug.TileDataWindow.draw_overlay"><code class="name flex">
<span>def <span class="ident">draw_overlay</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def draw_overlay(self):
    # Mark selected tiles
    for t in marked_tiles:
        column = t.tile_identifier % (self.width//8)
        row = t.tile_identifier // (self.width//8)
        # Yes, we are using the height as width. This is because we present the tile data from left to right,
        # but the sprites with a height of 16, renders them stacked ontop of each other.
        self.mark_tile(column*8, row*8, t.mark_color, t.sprite_height, 8, True)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.TileDataWindow.handle_events"><code class="name flex">
<span>def <span class="ident">handle_events</span></span>(<span>self, events)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_events(self, events):
    global mark_counter, marked_tiles
    # Feed events into the loop
    events = BaseDebugWindow.handle_events(self, events)
    for event in events:
        if event == WindowEvent._INTERNAL_MOUSE and event.window_id == self.window_id:
            if event.mouse_button == 0:
                tile_x, tile_y = event.mouse_x // self.scale // 8, event.mouse_y // self.scale // 8
                tile_identifier = tile_y * (self.width//8) + tile_x
                marked_tiles.add(
                    MarkedTile(
                        tile_identifier=tile_identifier,
                        mark_id=&#34;TILE&#34;,
                        mark_color=MARK[mark_counter]
                    )
                )
                mark_counter += 1
                mark_counter %= len(MARK)
            elif event.mouse_button == 1:
                marked_tiles.clear()
        elif event == WindowEvent._INTERNAL_MARK_TILE:
            marked_tiles.add(event.tile_identifier)
    return events</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.TileDataWindow.post_tick"><code class="name flex">
<span>def <span class="ident">post_tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def post_tick(self):
    tile_cache0 = self.renderer._tilecache

    for t in range(constants.TILES):
        xx = (t * 8) % self.width
        yy = ((t * 8) // self.width)*8
        self.copy_tile(tile_cache0, t, xx, yy, self.buf0)

    self.draw_overlay()
    BaseDebugWindow.post_tick(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyboy.plugins.debug.TileViewWindow"><code class="flex name class">
<span>class <span class="ident">TileViewWindow</span></span>
<span>(</span><span>*args, window_map, scanline_x, scanline_y, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TileViewWindow(BaseDebugWindow):
    def __init__(self, *args, window_map, scanline_x, scanline_y, **kwargs):
        super().__init__(*args, **kwargs)
        self.scanline_x, self.scanline_y = scanline_x, scanline_y
        self.color = COLOR_WINDOW if window_map else COLOR_BACKGROUND

        if not cythonmode:
            self.tilemap = tilemap.TileMap(self.mb, &#34;WINDOW&#34; if window_map else &#34;BACKGROUND&#34;)

    def __cinit__(self, pyboy, mb, *args, window_map, **kwargs):
        self.tilemap = tilemap.TileMap(self.mb, &#34;WINDOW&#34; if window_map else &#34;BACKGROUND&#34;)

    def post_tick(self):
        tile_cache0 = self.renderer._tilecache

        # Updating screen buffer by copying tiles from cache
        mem_offset = self.tilemap.map_offset - constants.VRAM_OFFSET
        for n in range(mem_offset, mem_offset + 0x400):
            tile_index = self.mb.lcd.VRAM[n]

            # Check the tile source and add offset
            # http://problemkaputt.de/pandocs.htm#lcdcontrolregister
            # BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
            if self.mb.lcd.LCDC.tiledata_select == 0:
                # (x ^ 0x80 - 128) to convert to signed, then add 256 for offset (reduces to + 128)
                tile_index = (tile_index ^ 0x80) + 128

            tile_column = (n-mem_offset) % 32
            tile_row = (n-mem_offset) // 32

            self.copy_tile(tile_cache0, tile_index, tile_column * 8, tile_row * 8, self.buf0)

        self.draw_overlay()
        BaseDebugWindow.post_tick(self)

    def handle_events(self, events):
        global mark_counter, marked_tiles

        self.tilemap.refresh_lcdc()

        # Feed events into the loop
        events = BaseDebugWindow.handle_events(self, events)
        for event in events:
            if event == WindowEvent._INTERNAL_MOUSE and event.window_id == self.window_id:
                if event.mouse_button == 0:
                    tile_x, tile_y = event.mouse_x // self.scale // 8, event.mouse_y // self.scale // 8
                    tile_identifier = self.tilemap.tile_identifier(tile_x, tile_y)
                    logger.info(f&#34;Tile clicked on {tile_x}, {tile_y}&#34;)
                    marked_tiles.add(
                        MarkedTile(
                            tile_identifier=tile_identifier,
                            mark_id=&#34;TILE&#34;,
                            mark_color=MARK[mark_counter]
                        )
                    )
                    mark_counter += 1
                    mark_counter %= len(MARK)
                elif event.mouse_button == 1:
                    marked_tiles.clear()
            elif event == WindowEvent._INTERNAL_MARK_TILE:
                marked_tiles.add(event.tile_identifier)

        return events

    def update_title(self):
        title = self.base_title
        title += &#34; [HIGH MAP 0x9C00-0x9FFF]&#34; if self.tilemap.map_offset == constants.HIGH_TILEMAP else \
            &#34; [LOW MAP 0x9800-0x9BFF]&#34;
        title += &#34; [HIGH DATA (SIGNED) 0x8800-0x97FF]&#34; if self.tilemap.signed_tile_data else \
            &#34; [LOW DATA (UNSIGNED) 0x8000-0x8FFF]&#34;
        if self.tilemap._select == &#34;WINDOW&#34;:
            title += &#34; [Window]&#34;
        if self.tilemap._select == &#34;BACKGROUND&#34;:
            title += &#34; [Background]&#34;
        sdl2.SDL_SetWindowTitle(self._window, title.encode(&#39;utf8&#39;))

    def draw_overlay(self):
        global marked_tiles
        scanlineparameters = self.pyboy.screen().tilemap_position_list()

        # Mark screen area
        for y in range(constants.ROWS):
            xx = int(scanlineparameters[y][self.scanline_x])
            yy = int(scanlineparameters[y][self.scanline_y])
            if y == 0 or y == constants.ROWS-1:
                for x in range(constants.COLS):
                    self.buf0[(yy+y) % 0xFF][(xx+x) % 0xFF] = COLOR
            else:
                self.buf0[(yy+y) % 0xFF][xx % 0xFF] = COLOR
                for x in range(constants.COLS):
                    self.buf0[(yy+y) % 0xFF][(xx+x) % 0xFF] &amp;= self.color
                self.buf0[(yy+y) % 0xFF][(xx+constants.COLS) % 0xFF] = COLOR

        # Mark selected tiles
        for t, match in zip(
            marked_tiles,
            self.tilemap.search_for_identifiers([m.tile_identifier for m in marked_tiles])
        ):
            for row, column in match:
                self.mark_tile(column * 8, row * 8, t.mark_color, 8, 8, True)
        if self.hover_x != -1:
            self.mark_tile(self.hover_x, self.hover_y, HOVER, 8, 8, True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyboy.plugins.debug.BaseDebugWindow</li>
<li><a title="pyboy.plugins.base_plugin.PyBoyWindowPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyWindowPlugin">PyBoyWindowPlugin</a></li>
<li><a title="pyboy.plugins.base_plugin.PyBoyPlugin" href="base_plugin.html#pyboy.plugins.base_plugin.PyBoyPlugin">PyBoyPlugin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyboy.plugins.debug.TileViewWindow.draw_overlay"><code class="name flex">
<span>def <span class="ident">draw_overlay</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def draw_overlay(self):
    global marked_tiles
    scanlineparameters = self.pyboy.screen().tilemap_position_list()

    # Mark screen area
    for y in range(constants.ROWS):
        xx = int(scanlineparameters[y][self.scanline_x])
        yy = int(scanlineparameters[y][self.scanline_y])
        if y == 0 or y == constants.ROWS-1:
            for x in range(constants.COLS):
                self.buf0[(yy+y) % 0xFF][(xx+x) % 0xFF] = COLOR
        else:
            self.buf0[(yy+y) % 0xFF][xx % 0xFF] = COLOR
            for x in range(constants.COLS):
                self.buf0[(yy+y) % 0xFF][(xx+x) % 0xFF] &amp;= self.color
            self.buf0[(yy+y) % 0xFF][(xx+constants.COLS) % 0xFF] = COLOR

    # Mark selected tiles
    for t, match in zip(
        marked_tiles,
        self.tilemap.search_for_identifiers([m.tile_identifier for m in marked_tiles])
    ):
        for row, column in match:
            self.mark_tile(column * 8, row * 8, t.mark_color, 8, 8, True)
    if self.hover_x != -1:
        self.mark_tile(self.hover_x, self.hover_y, HOVER, 8, 8, True)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.TileViewWindow.handle_events"><code class="name flex">
<span>def <span class="ident">handle_events</span></span>(<span>self, events)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def handle_events(self, events):
    global mark_counter, marked_tiles

    self.tilemap.refresh_lcdc()

    # Feed events into the loop
    events = BaseDebugWindow.handle_events(self, events)
    for event in events:
        if event == WindowEvent._INTERNAL_MOUSE and event.window_id == self.window_id:
            if event.mouse_button == 0:
                tile_x, tile_y = event.mouse_x // self.scale // 8, event.mouse_y // self.scale // 8
                tile_identifier = self.tilemap.tile_identifier(tile_x, tile_y)
                logger.info(f&#34;Tile clicked on {tile_x}, {tile_y}&#34;)
                marked_tiles.add(
                    MarkedTile(
                        tile_identifier=tile_identifier,
                        mark_id=&#34;TILE&#34;,
                        mark_color=MARK[mark_counter]
                    )
                )
                mark_counter += 1
                mark_counter %= len(MARK)
            elif event.mouse_button == 1:
                marked_tiles.clear()
        elif event == WindowEvent._INTERNAL_MARK_TILE:
            marked_tiles.add(event.tile_identifier)

    return events</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.TileViewWindow.post_tick"><code class="name flex">
<span>def <span class="ident">post_tick</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def post_tick(self):
    tile_cache0 = self.renderer._tilecache

    # Updating screen buffer by copying tiles from cache
    mem_offset = self.tilemap.map_offset - constants.VRAM_OFFSET
    for n in range(mem_offset, mem_offset + 0x400):
        tile_index = self.mb.lcd.VRAM[n]

        # Check the tile source and add offset
        # http://problemkaputt.de/pandocs.htm#lcdcontrolregister
        # BG &amp; Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
        if self.mb.lcd.LCDC.tiledata_select == 0:
            # (x ^ 0x80 - 128) to convert to signed, then add 256 for offset (reduces to + 128)
            tile_index = (tile_index ^ 0x80) + 128

        tile_column = (n-mem_offset) % 32
        tile_row = (n-mem_offset) // 32

        self.copy_tile(tile_cache0, tile_index, tile_column * 8, tile_row * 8, self.buf0)

    self.draw_overlay()
    BaseDebugWindow.post_tick(self)</code></pre>
</details>
</dd>
<dt id="pyboy.plugins.debug.TileViewWindow.update_title"><code class="name flex">
<span>def <span class="ident">update_title</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update_title(self):
    title = self.base_title
    title += &#34; [HIGH MAP 0x9C00-0x9FFF]&#34; if self.tilemap.map_offset == constants.HIGH_TILEMAP else \
        &#34; [LOW MAP 0x9800-0x9BFF]&#34;
    title += &#34; [HIGH DATA (SIGNED) 0x8800-0x97FF]&#34; if self.tilemap.signed_tile_data else \
        &#34; [LOW DATA (UNSIGNED) 0x8000-0x8FFF]&#34;
    if self.tilemap._select == &#34;WINDOW&#34;:
        title += &#34; [Window]&#34;
    if self.tilemap._select == &#34;BACKGROUND&#34;:
        title += &#34; [Background]&#34;
    sdl2.SDL_SetWindowTitle(self._window, title.encode(&#39;utf8&#39;))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyboy.plugins" href="index.html">pyboy.plugins</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyboy.plugins.debug.make_buffer" href="#pyboy.plugins.debug.make_buffer">make_buffer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyboy.plugins.debug.BaseDebugWindow" href="#pyboy.plugins.debug.BaseDebugWindow">BaseDebugWindow</a></code></h4>
<ul class="two-column">
<li><code><a title="pyboy.plugins.debug.BaseDebugWindow.copy_tile" href="#pyboy.plugins.debug.BaseDebugWindow.copy_tile">copy_tile</a></code></li>
<li><code><a title="pyboy.plugins.debug.BaseDebugWindow.handle_events" href="#pyboy.plugins.debug.BaseDebugWindow.handle_events">handle_events</a></code></li>
<li><code><a title="pyboy.plugins.debug.BaseDebugWindow.mark_tile" href="#pyboy.plugins.debug.BaseDebugWindow.mark_tile">mark_tile</a></code></li>
<li><code><a title="pyboy.plugins.debug.BaseDebugWindow.post_tick" href="#pyboy.plugins.debug.BaseDebugWindow.post_tick">post_tick</a></code></li>
<li><code><a title="pyboy.plugins.debug.BaseDebugWindow.stop" href="#pyboy.plugins.debug.BaseDebugWindow.stop">stop</a></code></li>
<li><code><a title="pyboy.plugins.debug.BaseDebugWindow.update_title" href="#pyboy.plugins.debug.BaseDebugWindow.update_title">update_title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.plugins.debug.Debug" href="#pyboy.plugins.debug.Debug">Debug</a></code></h4>
<ul class="">
<li><code><a title="pyboy.plugins.debug.Debug.argv" href="#pyboy.plugins.debug.Debug.argv">argv</a></code></li>
<li><code><a title="pyboy.plugins.debug.Debug.enabled" href="#pyboy.plugins.debug.Debug.enabled">enabled</a></code></li>
<li><code><a title="pyboy.plugins.debug.Debug.handle_events" href="#pyboy.plugins.debug.Debug.handle_events">handle_events</a></code></li>
<li><code><a title="pyboy.plugins.debug.Debug.post_tick" href="#pyboy.plugins.debug.Debug.post_tick">post_tick</a></code></li>
<li><code><a title="pyboy.plugins.debug.Debug.stop" href="#pyboy.plugins.debug.Debug.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.plugins.debug.MarkedTile" href="#pyboy.plugins.debug.MarkedTile">MarkedTile</a></code></h4>
</li>
<li>
<h4><code><a title="pyboy.plugins.debug.SpriteViewWindow" href="#pyboy.plugins.debug.SpriteViewWindow">SpriteViewWindow</a></code></h4>
<ul class="">
<li><code><a title="pyboy.plugins.debug.SpriteViewWindow.draw_overlay" href="#pyboy.plugins.debug.SpriteViewWindow.draw_overlay">draw_overlay</a></code></li>
<li><code><a title="pyboy.plugins.debug.SpriteViewWindow.post_tick" href="#pyboy.plugins.debug.SpriteViewWindow.post_tick">post_tick</a></code></li>
<li><code><a title="pyboy.plugins.debug.SpriteViewWindow.update_title" href="#pyboy.plugins.debug.SpriteViewWindow.update_title">update_title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.plugins.debug.SpriteWindow" href="#pyboy.plugins.debug.SpriteWindow">SpriteWindow</a></code></h4>
<ul class="">
<li><code><a title="pyboy.plugins.debug.SpriteWindow.draw_overlay" href="#pyboy.plugins.debug.SpriteWindow.draw_overlay">draw_overlay</a></code></li>
<li><code><a title="pyboy.plugins.debug.SpriteWindow.handle_events" href="#pyboy.plugins.debug.SpriteWindow.handle_events">handle_events</a></code></li>
<li><code><a title="pyboy.plugins.debug.SpriteWindow.post_tick" href="#pyboy.plugins.debug.SpriteWindow.post_tick">post_tick</a></code></li>
<li><code><a title="pyboy.plugins.debug.SpriteWindow.update_title" href="#pyboy.plugins.debug.SpriteWindow.update_title">update_title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.plugins.debug.TileDataWindow" href="#pyboy.plugins.debug.TileDataWindow">TileDataWindow</a></code></h4>
<ul class="">
<li><code><a title="pyboy.plugins.debug.TileDataWindow.draw_overlay" href="#pyboy.plugins.debug.TileDataWindow.draw_overlay">draw_overlay</a></code></li>
<li><code><a title="pyboy.plugins.debug.TileDataWindow.handle_events" href="#pyboy.plugins.debug.TileDataWindow.handle_events">handle_events</a></code></li>
<li><code><a title="pyboy.plugins.debug.TileDataWindow.post_tick" href="#pyboy.plugins.debug.TileDataWindow.post_tick">post_tick</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyboy.plugins.debug.TileViewWindow" href="#pyboy.plugins.debug.TileViewWindow">TileViewWindow</a></code></h4>
<ul class="">
<li><code><a title="pyboy.plugins.debug.TileViewWindow.draw_overlay" href="#pyboy.plugins.debug.TileViewWindow.draw_overlay">draw_overlay</a></code></li>
<li><code><a title="pyboy.plugins.debug.TileViewWindow.handle_events" href="#pyboy.plugins.debug.TileViewWindow.handle_events">handle_events</a></code></li>
<li><code><a title="pyboy.plugins.debug.TileViewWindow.post_tick" href="#pyboy.plugins.debug.TileViewWindow.post_tick">post_tick</a></code></li>
<li><code><a title="pyboy.plugins.debug.TileViewWindow.update_title" href="#pyboy.plugins.debug.TileViewWindow.update_title">update_title</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>